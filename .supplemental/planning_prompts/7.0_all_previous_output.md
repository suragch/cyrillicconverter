# Cyrillic-Traditional Mongolian Converter: Project Specification v3

## Elevator Pitch
A privacy-first web app that converts Cyrillic Mongolian text to Traditional Mongolian script instantly in your browser—no server uploads required. Built on crowdsourced translation data with rigorous quality control, it empowers the Mongolian community to preserve and improve their linguistic heritage collaboratively while maintaining complete text privacy. Users can contribute translations that are immediately available locally, even before moderator approval.

## Problem Statement
Mongolian speakers who want to convert between Cyrillic and Traditional Mongolian script face several challenges:
- **Privacy concerns**: Existing tools often require uploading documents to external servers
- **Incomplete dictionaries**: Many proper nouns, technical terms, and modern vocabulary lack Traditional Mongolian equivalents
- **Limited community input**: Translations are often siloed, with no mechanism for collective improvement
- **Quality inconsistency**: Multiple valid spellings exist without guidance on which to use
- **Immediate needs vs community building**: Users need translations now but also want to contribute to shared knowledge

## Target Audience
**Primary Users:**
- Mongolian language learners and educators
- Cultural preservationists and historians
- Writers and content creators working with Traditional Mongolian script
- Government and institutional workers needing script conversion

**Secondary Users:**
- Linguists and researchers
- Diaspora communities reconnecting with traditional script
- Tourists and casual users exploring Mongolian language

## USP
- **Privacy-by-design**: All conversions happen client-side in the browser with no server uploads
- **Zero-friction access**: Instant conversion without signup
- **Immediate + community benefit**: Contributions are available locally instantly AND shared with community after moderation
- **Dual-layer dictionary**: User's personal dictionary + shared community dictionary
- **Rigorous quality control**: Multi-tier moderation system (net +5 approvals = fully accepted, net -3 = rejected)
- **Context-aware contributions**: Reviewers see surrounding words to validate rare/unusual terms
- **Progressive Web App**: Works offline with automatic database updates when online

## Target Platforms
- **Primary**: Progressive Web App (PWA) for modern browsers (Chrome, Firefox, Safari, Edge)
- **Responsive design**: Desktop and mobile web
- **Offline-first**: Full functionality without internet connection once dictionary is cached

---

## Features List

### Core Conversion Feature
- [ ] **As a user, I can paste or type Cyrillic text into an input area** so that I can convert it to Traditional Mongolian
  - [ ] Input field supports unlimited text length (with performance considerations)
  - [ ] Real-time character count displayed
  - [ ] Clear/reset button to empty input field for new conversions
- [ ] **As a user, I can click a "Convert" button** to transform my Cyrillic text to Traditional Mongolian
  - [ ] Conversion happens entirely in browser (client-side JavaScript)
  - [ ] No loading indicator needed (should be near-instant with local processing)
  - [ ] Abbreviation expansion happens first (lookup in abbreviation dictionary)
  - [ ] Then direct dictionary lookup for word-by-word conversion
  - [ ] Lookup order: User's local dictionary → Shared community dictionary
- [ ] **As a user, unconverted words remain in Cyrillic** in the output so I know what needs translation
  - [ ] Unconverted words are visually highlighted (e.g., red underline or different styling)
  - [ ] Clickable to contribute translation
- [ ] **As a user, I can copy the converted text with one click** to use it elsewhere
  - [ ] "Copy to Clipboard" button with visual confirmation feedback
  - [ ] **Conversion from Menksoft code to Unicode happens during copy operation**
  - [ ] Display uses Menksoft font/encoding
  - [ ] Clipboard receives Unicode-encoded Traditional Mongolian
  - [ ] Fallback mechanism for browsers without Clipboard API

### Menksoft-Unicode Handling
- [ ] **The system displays Traditional Mongolian using Menksoft font** for visual rendering
  - [ ] Web font provided and loaded for consistent display
  - [ ] Menksoft encoding used internally for display
- [ ] **The system converts Menksoft to Unicode on copy** for compatibility
  - [ ] Algorithm provided by you (ported from Dart) will be implemented
  - [ ] Conversion happens transparently to user
  - [ ] Unicode output is clipboard-ready

### Abbreviation Handling
- [ ] **The system automatically detects abbreviations** before conversion
  - [ ] Detection rule: Any word that is more than one letter and all caps
  - [ ] Examples: БНМАУ, ЦБД, УБ
- [ ] **As a user, I am prompted to expand abbreviations** when detected and not in dictionary
  - [ ] Modal/dialog appears asking: "What does [abbreviation] stand for?"
  - [ ] User provides full expansion
  - [ ] System uses expansion for conversion in current session
  - [ ] User can choose to save expansion locally and/or submit to server
- [ ] **Abbreviation expansions are stored in dictionary** (both local and server)
  - [ ] Abbreviations go through same moderation process as word pairs
  - [ ] Multiple valid expansions supported (user chooses during conversion)
  - [ ] Database schema similar to word pairs: abbreviation, expansion, status, approvals, etc.

### Multiple Translation Options (One-to-Many)
- [ ] **As a user, I am presented with choices** when multiple Traditional Mongolian spellings exist for a Cyrillic word
  - [ ] Dialog shows the Cyrillic word and 2+ Traditional Mongolian options (rendered in Menksoft)
  - [ ] Radio button selection
  - [ ] User selects preferred translation
  - [ ] Checkbox: "Use this choice for all instances of '[word]' in this document"
  - [ ] System remembers choice for current session/document only
  - [ ] All instances are updated if "use for all" is selected
- [ ] **System does NOT track** which variant is most commonly selected (future feature)

### Dictionary & Crowdsourcing - Dual-Layer System
- [ ] **As a user, I have both a local dictionary AND access to shared dictionary**
  - [ ] Local dictionary: User's personal contributions and choices (stored in IndexedDB)
  - [ ] Shared dictionary: Community-approved translations (synced from server)
  - [ ] Conversion lookup priority: Local first, then shared
- [ ] **As a user, I can click on unconverted words** to contribute their translation
  - [ ] Unconverted words are visually highlighted (e.g., red underline or different styling)
  - [ ] Clicking opens a contribution modal/panel
  - [ ] Anonymous users can contribute (IP address recorded but not displayed publicly)
- [ ] **As a contributor, I see context when adding translations** to help reviewers validate rare words
  - [ ] Display **2 words before and 2 words after** the target word
  - [ ] Context stops at punctuation boundaries (period, comma, semicolon, etc.)
  - [ ] Context is read-only, for reference during review
  - [ ] Cyrillic word pre-populated in input field
  - [ ] Latin character input field for Traditional Mongolian transliteration (custom romanization system)
  - [ ] Live preview of Traditional Mongolian script (Menksoft) as Latin characters are typed
- [ ] **As a contributor, I can use a popup keyboard** to help with Latin-to-Mongolian character mappings
  - [ ] Optional on-screen keyboard showing key mappings
  - [ ] Keyboard can be toggled on/off
  - [ ] Visual guide showing which Latin letters map to which Mongolian characters (custom system provided later)
- [ ] **As a contributor, I can choose where to save my contribution**
  - [ ] Option 1: "Save locally only" - Immediately available in user's local dictionary
  - [ ] Option 2: "Save locally AND submit for review" - Available locally + submitted to server for moderation
  - [ ] Both options make the word immediately usable for the contributor
  - [ ] Server submissions go through moderation process
  - [ ] **Even if rejected by moderators, word remains in user's local dictionary**
- [ ] **Contributions are recorded with metadata** for moderation tracking (server submissions only)
  - [ ] Logged-in users: user ID, timestamp
  - [ ] Anonymous users: IP address, timestamp
  - [ ] Word status: pending, probation (net positive approvals), accepted (net +5 approvals), rejected (net -3 approvals)
  - [ ] Approval count: Net count of approvals minus rejections

### User Authentication & Moderation Application
- [ ] **As a user, I can sign up/log in via PocketBase** if I want to apply to become a moderator
  - [ ] PocketBase handles authentication
  - [ ] Email/password authentication
  - [ ] Optional: OAuth providers if supported by PocketBase
  - [ ] User can use core conversion features without ever signing up
- [ ] **As a logged-in user, I can apply to become a moderator** by completing an application
  - [ ] Application form includes:
    - [ ] **Test section**: Review 10 known words and mark correct/incorrect
    - [ ] Test words are the same for everyone (provided by you)
    - [ ] Passing threshold: 9/10 correct
    - [ ] **Self-description**: Text area for skills/experience in Traditional Mongolian
  - [ ] Application is submitted to existing moderators for review
  - [ ] Confirmation message: "Your application has been submitted"
- [ ] **As an existing moderator, I can review moderator applications** and approve/reject them
  - [ ] Dashboard section for pending applications
  - [ ] View applicant's test results (score out of 10) and their specific answers
  - [ ] View self-description
  - [ ] Approve or reject with optional feedback message
  - [ ] Approved applicants receive moderator privileges via PocketBase role assignment

### Moderation System
- [ ] **As a moderator, I can review and approve crowdsourced translations** to maintain quality
  - [ ] Dashboard showing pending submissions with context
  - [ ] **Context display: 2 words before/after (stopping at punctuation)** so moderators can validate rare words
  - [ ] View Cyrillic word and proposed Traditional Mongolian translation (Menksoft rendering)
  - [ ] **Blind review**: Cannot see who already approved/rejected
  - [ ] Approve/reject/edit capabilities
  - [ ] **First approval** moves word to "probation" status (immediately available to all users in MVP)
  - [ ] **Net +5 approvals** moves word to "fully accepted" status
  - [ ] **Net -3 rejections** marks word as "rejected" (not shown to users)
  - [ ] **Approval/rejection math**: Each approval adds +1, each rejection adds -1
- [ ] **As a moderator, I can edit existing dictionary entries** to fix errors
  - [ ] Search functionality to find existing entries
  - [ ] Edit interface similar to contribution interface
  - [ ] **Editing Cyrillic**: Creates a new database entry (different word)
  - [ ] **Editing Traditional Mongolian (Latin)**: Resets approval count to +1
  - [ ] Last write wins in case of simultaneous edits (rare edge case)
  - [ ] Change history/audit log showing who edited when
- [ ] **As a moderator, I can add additional Traditional Mongolian spellings** for an existing Cyrillic word
  - [ ] Creates new database entry with same Cyrillic but different Traditional Mongolian
  - [ ] New entry goes through moderation process independently
  - [ ] Results in one-to-many relationship for that Cyrillic word
- [ ] **The system tracks moderation quality** for transparency
  - [ ] Number of approvals, rejections, edits per moderator
  - [ ] Inter-moderator agreement rates (future enhancement)
  - [ ] Contribution approval rates

### Contributor Recognition
- [ ] **As a logged-in user, I can view my contribution statistics** on my profile
  - [ ] Total words contributed to server
  - [ ] Total words in local dictionary only
  - [ ] Acceptance rate (net positive vs rejected)
  - [ ] Words in probation vs fully accepted vs rejected
- [ ] **As a logged-in user, I can edit my pending contributions** before they're fully approved or rejected
  - [ ] Search or filter personal contributions
  - [ ] Edit interface opens with current values
  - [ ] Submit edited version (resets approval count to 0)
- [ ] **As a user, I can view a public leaderboard** of top contributors
  - [ ] Top contributors by total words added to server
  - [ ] Top contributors by acceptance rate (with minimum threshold, e.g., 10+ contributions)
  - [ ] Anonymous contributions are not displayed on leaderboard
  - [ ] Only logged-in user contributions appear

### Data Management & PWA

#### Database Schema

**Word Conversion Pairs Table (PostgreSQL or PocketBase)**
- [ ] word_id (primary key)
- [ ] cyrillic_word (indexed)
- [ ] traditional_mongolian_menksoft
- [ ] traditional_mongolian_latin
- [ ] context_before
- [ ] context_after
- [ ] status (pending/probation/accepted/rejected)
- [ ] approval_count (net count: approvals - rejections, indexed)
- [ ] contributor_id (nullable, foreign key to users)
- [ ] contributor_ip (nullable, hashed for privacy)
- [ ] created_at
- [ ] updated_at

**Abbreviation Expansions Table**
- [ ] abbreviation_id (primary key)
- [ ] abbreviation (indexed, e.g., "БНМАУ")
- [ ] expansion (e.g., "Бүгд Найрамдах Монгол Ард Улс")
- [ ] status (pending/probation/accepted/rejected)
- [ ] approval_count (net count)
- [ ] contributor_id (nullable)
- [ ] contributor_ip (nullable, hashed)
- [ ] created_at
- [ ] updated_at

**Moderator Actions Table**
- [ ] action_id (primary key)
- [ ] word_id or abbreviation_id (foreign key)
- [ ] moderator_id (foreign key to users)
- [ ] action_type (approve/reject/edit)
- [ ] timestamp
- [ ] notes (optional, internal only)

**Users Table (PocketBase)**
- [ ] Handled by PocketBase authentication
- [ ] Additional fields: is_moderator (boolean), moderator_approved_at

**Moderator Applications Table**
- [ ] application_id (primary key)
- [ ] user_id (foreign key)
- [ ] test_score (integer, 0-10)
- [ ] test_answers (JSON or text)
- [ ] self_description (text)
- [ ] status (pending/approved/rejected)
- [ ] reviewed_by (moderator_id, nullable)
- [ ] reviewed_at (nullable)
- [ ] created_at

#### Sync Strategy
- [ ] **The system stores crowdsourced translations on server** for community benefit
  - [ ] API endpoints for submitting new translations (words and abbreviations)
  - [ ] API endpoints for fetching dictionary data
  - [ ] API endpoints for moderator actions
- [ ] **The system uses a hybrid sync strategy** for optimal performance
  - [ ] **Full dictionary download**: When major update available (versioned)
    - [ ] Compressed dictionary (~3 MB for 2M pairs) downloaded as gzip
    - [ ] Includes words with status = probation or accepted (net approval_count >= 1)
    - [ ] Excludes rejected words (net approval_count <= -3)
    - [ ] Stored in IndexedDB for offline access
    - [ ] Versioned (e.g., v1.2.0) to track updates
  - [ ] **Incremental updates**: Fetch only changed words between full downloads
    - [ ] Delta sync API endpoint returns words added/modified since last sync timestamp
    - [ ] Updates local IndexedDB with deltas
  - [ ] **Update frequency**:
    - [ ] Initial phase: ~Weekly full updates
    - [ ] Stable phase: ~Monthly full updates
    - [ ] Incremental updates: As needed between full updates
- [ ] **Progressive Web App (PWA) functionality** for offline use
  - [ ] Service worker caches app shell, Menksoft font, and dictionary
  - [ ] Works fully offline once dictionary is downloaded
  - [ ] **Auto-update**: Background sync downloads new dictionary version when available
  - [ ] Silent notification or subtle indicator when update completes
  - [ ] No user prompt for updates (auto-apply)
  - [ ] **Offline contribution behavior**: 
    - [ ] Users can still add to local dictionary
    - [ ] Server submission disabled with message: "You're offline. This word is saved locally and will be available for server submission when you reconnect."
    - [ ] Option to queue server submissions for when online returns (future enhancement)

#### Initial Data Seeding
- [ ] **Existing word list of 20,000-30,000 words** seeded into database
  - [ ] All seeded words set to status = probation
  - [ ] All seeded words set to approval_count = 1
  - [ ] Contributor marked as "system" or special seeding account
  - [ ] These words immediately available to users in MVP

---

## UX/UI Considerations

### Main Conversion Screen
- [ ] **Split-pane layout** with input on left, output on right (desktop) or stacked (mobile)
  - [ ] Clean, minimal interface focusing on the conversion task
  - [ ] Cyrillic input uses appropriate Cyrillic font
  - [ ] Traditional Mongolian output displays vertically with Menksoft font
- [ ] **Empty state**: Helpful placeholder text guiding first-time users
  - [ ] Example: "Paste your Cyrillic Mongolian text here to convert it to Traditional Mongolian script"
  - [ ] Optional: Sample text link to try out the converter
- [ ] **Filled state**: Text populated with clear visual separation
- [ ] **Converted state**: Output area populated with Traditional Mongolian text
  - [ ] Unconverted words highlighted in distinct color (e.g., red or orange underline)
  - [ ] Copy button becomes prominent
  - [ ] Character/word count displayed
- [ ] **Offline indicator**: Subtle badge showing "Offline" status with checkmark (still functional)

### Abbreviation Expansion Dialog
- [ ] **Triggered state**: Modal appears when abbreviation detected during conversion and not in dictionary
  - [ ] Shows detected abbreviation in clear typography
  - [ ] Prompt: "What does [ABC] stand for?"
  - [ ] Text input for full expansion
  - [ ] "Skip" button to leave abbreviated
  - [ ] "Save & Expand" button with options:
    - [ ] Radio/checkbox: "Save locally only" or "Save locally AND submit for review"
- [ ] **Multiple abbreviations**: Queue them and show one at a time

### One-to-Many Choice Dialog
- [ ] **Triggered state**: Modal appears when word has multiple Traditional Mongolian spellings in dictionary
  - [ ] Displays Cyrillic word prominently at top
  - [ ] Radio button list of Traditional Mongolian options (rendered in Menksoft)
  - [ ] Each option on separate line for clarity
  - [ ] Checkbox: "Use this choice for all instances of '[word]' in this document" 
  - [ ] "Cancel" (skip this word, leave unconverted) and "Apply" buttons
  - [ ] Choice persists only for current session
- [ ] **Batch processing**: If multiple words have choices, show them sequentially

### Contribution Modal/Panel
- [ ] **Triggered state**: Modal appears when user clicks unconverted word
  - [ ] Semi-transparent overlay darkens background
  - [ ] Modal centered on screen (or bottom sheet on mobile)
  - [ ] Title: "Add Translation for '[word]'"
- [ ] **Context display section**:
  - [ ] Read-only text showing 2 words before/after (stopping at punctuation)
  - [ ] Target word highlighted in bold or different color
  - [ ] Muted/secondary styling to show it's reference-only
  - [ ] Label: "Context (for reviewers)"
- [ ] **Input sections**:
  - [ ] Cyrillic input: Pre-filled with clicked word, editable if needed
  - [ ] Latin transliteration input: Active focus state, character counter
  - [ ] Live preview: Updates in real-time as user types, shows Menksoft rendering
  - [ ] Help text with link: "Use the custom romanization system (see guide)"
- [ ] **Keyboard toggle**: Button to show/hide on-screen keyboard
  - [ ] Smooth slide-in/out animation
  - [ ] Keys highlight on hover/press
  - [ ] Key mapping labels visible (Latin → Mongolian, provided later)
- [ ] **Save options**:
  - [ ] Radio buttons or segmented control:
    - [ ] "Save locally only" (default for quick workflow)
    - [ ] "Save locally AND submit for review"
  - [ ] Help text: "Local saves are available immediately. Server submissions help the community after moderation."
- [ ] **Submit states**:
  - [ ] Validation: Error messages for required fields
  - [ ] Submitting: Loading state on button
  - [ ] Success (local only): "Saved to your personal dictionary!" confirmation, modal closes
  - [ ] Success (local + server): "Saved locally and submitted for review!" confirmation, modal closes
  - [ ] Error: Inline error message, modal remains open for retry
- [ ] **Anonymous contribution note**: Small text indicating "Contributing anonymously" if not logged in (when submitting to server)
- [ ] **Offline behavior**: If offline and user attempts server submission, show message: "You're offline. Word saved locally only. Submit to server when reconnected."

### Authentication Screens
- [ ] **Login/Signup modal or page (PocketBase integration)**
  - [ ] Tab toggle between "Login" and "Sign Up"
  - [ ] Form validation with inline error messages
  - [ ] Password strength indicator for signup
  - [ ] Success: Redirect to profile/dashboard or close modal
  - [ ] PocketBase handles session management
- [ ] **Logged-in state**: User avatar/name in header with dropdown menu
  - [ ] Links to: Profile, Apply to Moderate (if not moderator), Dashboard (if moderator), Logout

### Moderator Application Screen
- [ ] **Multi-step wizard or single-page form**
  - [ ] **Step 1: Test section** with 10 known words
    - [ ] Same 10 words in same order for all applicants (provided by you)
    - [ ] Each word shows: Cyrillic input, Traditional Mongolian output, Context
    - [ ] Radio buttons: "Correct" or "Incorrect"
    - [ ] Auto-score on submit: Must score 9/10 to pass
    - [ ] If fail (8 or below): Message "You need at least 9/10 correct. Please study and try again later." (with cooldown period?)
  - [ ] **Step 2: Self-description** (only if test passed)
    - [ ] Text area for skills/experience in Traditional Mongolian
    - [ ] Character count (minimum suggested: 100 characters)
  - [ ] Submit application button
  - [ ] Confirmation: "Your application has been submitted to moderators for review. You'll be notified via email if approved."

### Moderator Dashboard
- [ ] **Sidebar/tab navigation**:
  - [ ] Pending submissions (words & abbreviations)
  - [ ] Probation words (net 1-4 approvals)
  - [ ] Accepted words (net 5+ approvals)
  - [ ] Rejected words (net -3 or lower)
  - [ ] Moderator applications (if permission to review apps)
  - [ ] Statistics
- [ ] **Pending submissions list view**:
  - [ ] Table/card layout showing: Cyrillic word, context snippet, proposed Traditional Mongolian, date submitted
  - [ ] Filters: date range, type (word/abbreviation), has context
  - [ ] Sort: newest, oldest, random (to avoid bias)
  - [ ] **Blind review**: No contributor names or existing approval counts visible
- [ ] **Detail/review view**:
  - [ ] **Context displayed prominently**: 2 words before/after in read-only box with label
  - [ ] Cyrillic word (large, clear)
  - [ ] Proposed Traditional Mongolian (Menksoft rendering, large)
  - [ ] Latin transliteration (visible for reference, smaller)
  - [ ] Submission date
  - [ ] Action buttons:
    - [ ] "Approve" (+1 to approval count)
    - [ ] "Edit & Approve" (opens edit interface, then saves as +1 approval for edited version)
    - [ ] "Reject" (-1 to approval count, requires brief reason in dropdown or text)
  - [ ] **Similar words section**: Show existing dictionary entries with similar Cyrillic or Traditional Mongolian for reference
  - [ ] Notes field for moderation comments (internal, not shown to contributor)
  - [ ] **Status after action**: "Word approved. Current status: [Probation/Accepted]" or "Word rejected. Current net count: [-1]"
- [ ] **Moderator applications review** (if applicable):
  - [ ] List of pending applications
  - [ ] Detail view: Test score (9/10 or 10/10), individual answers, self-description
  - [ ] Approve/reject buttons
  - [ ] Optional feedback text to applicant

### Contributor Leaderboard Page
- [ ] **Public page accessible to all users**
  - [ ] Top 50 or 100 contributors listed
  - [ ] Columns: Username, Total Words Submitted, Acceptance Rate (% accepted), Fully Accepted Words
  - [ ] Filter/toggle: "All Time" vs "This Month" vs "This Year"
  - [ ] Note: "Anonymous contributions are not displayed. Only server submissions counted."

### Profile Page (Logged-in Users)
- [ ] **User statistics**:
  - [ ] Total contributions to server
  - [ ] Total words in personal local dictionary
  - [ ] Words in review (pending on server)
  - [ ] Words in probation (net 1-4 approvals)
  - [ ] Words fully accepted (net 5+ approvals)
  - [ ] Words rejected (net -3 or lower)
  - [ ] Acceptance rate percentage
- [ ] **Recent activity**: List of recent contributions with status
- [ ] **Edit contributions**: Link to view and edit pending contributions
  - [ ] List of user's pending/probation submissions
  - [ ] "Edit" button opens contribution modal pre-filled
  - [ ] Editing resets approval count to 0 (starts moderation over)
- [ ] **Settings**: Email, password change (via PocketBase), notification preferences

### Visual Hierarchy & Information Architecture
- [ ] **Primary action (Convert)**: Largest, most prominent button in main screen
- [ ] **Secondary actions (Copy, Clear)**: Smaller, less prominent but still accessible
- [ ] **Tertiary actions (Sign up, Help, Contribute)**: Text links or icon buttons
- [ ] **Progressive disclosure**: Advanced features (keyboard, moderation) hidden until needed
- [ ] **Responsive typography**: Legible fonts for Cyrillic, Latin, and Traditional Mongolian (Menksoft)
- [ ] **Color coding**: Consistent use of colors for status
  - [ ] Red/orange: Unconverted words, negative counts
  - [ ] Yellow/amber: Probation status
  - [ ] Green: Fully accepted status
  - [ ] Gray: Rejected (moderator view only)

### Animations & Microinteractions
- [ ] **Conversion**: Text appears smoothly in output (minimal animation since it's instant)
- [ ] **Copy confirmation**: Checkmark animation or toast notification ("Copied as Unicode!")
- [ ] **Unconverted word highlighting**: Gentle pulse or color shift on hover to indicate clickability
- [ ] **Modal transitions**: Smooth fade-in/scale-up animation for dialogs
- [ ] **Live preview**: Smooth character-by-character rendering as user types Latin transliteration
- [ ] **Button states**: Hover, active, disabled states with color/shadow changes
- [ ] **Database update indicator**: Subtle loading bar or notification when syncing dictionary updates (auto-update)
- [ ] **Local save confirmation**: Brief toast: "Saved to your dictionary!" when local-only save occurs

---

## Non-Functional Requirements

### Performance
- [ ] **Conversion completes in <500ms** for typical text (up to 1000 words)
  - [ ] Dictionary lookup optimized with efficient data structures (hash maps for Cyrillic keys)
  - [ ] No loading indicator needed due to speed
  - [ ] Lookup priority: User local dictionary (IndexedDB) → Shared dictionary (IndexedDB)
- [ ] **Dictionary loading strategy**:
  - [ ] Full dictionary: Compressed 3 MB download, ~50 MB uncompressed in memory (at 2M pairs)
  - [ ] Initial load: 20-30K pairs much smaller (~750 KB compressed)
  - [ ] Decompression happens asynchronously on load
  - [ ] IndexedDB storage for offline access (both shared and user-local dictionaries)
  - [ ] Incremental updates: Small delta fetches between full downloads
- [ ] **Page load time <3 seconds** on 3G connection (first visit)
  - [ ] Subsequent visits: <1 second (cached PWA)
- [ ] **Lazy loading** for moderator dashboard and non-critical features
- [ ] **Bundle size optimization**: Code splitting, tree shaking, minification
- [ ] **Menksoft font optimization**: Subset font if possible to reduce size

### Scalability
- [ ] **Client-side architecture** naturally scales (no server load for conversions)
- [ ] **Dictionary grows to 2 million pairs**:
  - [ ] Efficient data structures to handle large dictionary in memory (Map or Object with direct key access)
  - [ ] Indexing strategy for fast lookups even at scale
  - [ ] Consider Web Worker for dictionary operations if main thread blocking occurs (unlikely with hash map lookups)
- [ ] **API rate limiting** to prevent abuse:
  - [ ] Submission endpoint: 10 contributions per hour per IP/user
  - [ ] Dictionary sync endpoint: Reasonable rate limits for delta updates
  - [ ] Moderator action endpoints: Higher limits for trusted moderators
- [ ] **Database indexing** on frequently queried fields:
  - [ ] cyrillic_word (primary lookup key, unique if enforcing one spelling per submission)
  - [ ] status (for filtering pending/accepted/rejected)
  - [ ] approval_count (for filtering probation vs accepted)
  - [ ] contributor_id (for user statistics)
  - [ ] created_at, updated_at (for sorting and delta syncs)
- [ ] **CDN delivery** for static assets:
  - [ ] GitHub Pages + Cloudflare for frontend
  - [ ] Compressed dictionary files
  - [ ] Menksoft font file
- [ ] **Caching strategy**:
  - [ ] Dictionary: Long cache TTL, versioned (e.g., dictionary-v1.2.0.json.gz)
  - [ ] Service worker caching for PWA offline functionality

### Security
- [ ] **Input sanitization** to prevent XSS attacks:
  - [ ] All user-submitted Cyrillic and Latin text sanitized before storage
  - [ ] Output rendering uses proper escaping (DOMPurify or similar)
- [ ] **HTTPS only** for all server communication (enforced by Cloudflare and VPS config)
- [ ] **Authentication handled by PocketBase**:
  - [ ] JWT tokens or session cookies secured
  - [ ] httpOnly cookies for session tokens
- [ ] **Rate limiting** on submission and moderation endpoints:
  - [ ] Prevent spam submissions (10/hour per user/IP)
  - [ ] Prevent abuse of moderator actions
  - [ ] Prevent brute force on authentication
- [ ] **CORS policies** properly configured for API
  - [ ] Dart Shelf configured to accept requests from frontend domain only
- [ ] **Content Security Policy** headers to prevent injection attacks
- [ ] **Moderator permission checks** on server-side:
  - [ ] All moderator actions verified with PocketBase role/permission
  - [ ] Role-based access control (RBAC) for moderator vs regular user
  - [ ] Separate permission for reviewing moderator applications
- [ ] **IP address storage**: Comply with GDPR/privacy laws
  - [ ] IP addresses for anonymous contributions hashed (SHA-256) before storage
  - [ ] Not displayed publicly
  - [ ] Clear data retention policy (e.g., delete after 1 year or upon request)
- [ ] **SQL injection prevention**: Use parameterized queries or ORM (PostgreSQL)
- [ ] **Docker security**: VPS container best practices, non-root user, minimal attack surface

### Accessibility
- [ ] **WCAG 2.1 AA compliance** minimum target
- [ ] **Keyboard navigation** for all interactive elements:
  - [ ] Tab order logical and intuitive
  - [ ] Enter/Space activates buttons
  - [ ] Escape closes modals
  - [ ] Arrow keys for radio button groups
- [ ] **Screen reader support**:
  - [ ] Proper ARIA labels for all controls
  - [ ] Semantic HTML (button, nav, main, article, etc.)
  - [ ] Live regions for dynamic content (conversion results, notifications)
  - [ ] Alt text for icons and visual indicators
  - [ ] Descriptive button text ("Add translation for [word]" not just "Add")
- [ ] **Color contrast**: 
  - [ ] 4.5:1 minimum for normal text
  - [ ] 3:1 for large text and UI components
  - [ ] Unconverted word highlighting uses sufficient contrast (not relying on color alone)
- [ ] **Focus indicators**: Visible focus states for keyboard users (2px outline minimum, high contrast)
- [ ] **Error messages**: Announced to screen readers with role="alert"
- [ ] **Language attributes**: Proper lang tags
  - [ ] lang="mn-Cyrl" for Cyrillic Mongolian
  - [ ] lang="mn-Mong" for Traditional Mongolian
  - [ ] Helps screen readers with pronunciation
- [ ] **Resizable text**: Layout doesn't break at 200% zoom
- [ ] **Motion**: Respect prefers-reduced-motion for animations
- [ ] **Form labels**: All form inputs have associated labels (visible or aria-label)
- [ ] **Skip links**: "Skip to main content" link for keyboard users

---

## Technical Architecture

### Frontend Stack
- [ ] **Core framework**: Vanilla JavaScript or lightweight framework (React, Vue, or Svelte)
- [ ] **PWA**: Service Worker for offline functionality
- [ ] **Storage**: IndexedDB for dictionaries (user local + shared community)
- [ ] **Styling**: CSS or Tailwind CSS for responsive design
- [ ] **Build tool**: Vite or Webpack for bundling and optimization
- [ ] **Hosting**: GitHub Pages + Cloudflare CDN

### Backend Stack
- [ ] **API**: Dart Shelf server running in Docker on VPS
- [ ] **Authentication**: PocketBase (user accounts, roles, permissions)
- [ ] **Database**: PostgreSQL for dictionary data + PocketBase for auth
- [ ] **Deployment**: Docker container on VPS (self-hosted)
- [ ] **Reverse proxy**: Nginx or Caddy for HTTPS and routing

### API Endpoints (Dart Shelf)

**Dictionary Endpoints**
- [ ] `GET /api/dictionary/full?version=<timestamp>` - Download full dictionary (gzipped)
- [ ] `GET /api/dictionary/delta?since=<timestamp>` - Get incremental updates
- [ ] `POST /api/dictionary/word` - Submit new word contribution
- [ ] `PUT /api/dictionary/word/:id` - Edit existing word (user's own pending contributions)
- [ ] `POST /api/dictionary/abbreviation` - Submit new abbreviation expansion
- [ ] `PUT /api/dictionary/abbreviation/:id` - Edit existing abbreviation

**Moderation Endpoints (requires moderator role)**
- [ ] `GET /api/moderation/pending` - List pending submissions
- [ ] `GET /api/moderation/probation` - List probation words
- [ ] `GET /api/moderation/word/:id` - Get word details for review
- [ ] `POST /api/moderation/word/:id/approve` - Approve word (+1)
- [ ] `POST /api/moderation/word/:id/reject` - Reject word (-1)
- [ ] `PUT /api/moderation/word/:id/edit` - Edit and approve word

**Moderator Application Endpoints**
- [ ] `POST /api/moderator/apply` - Submit moderator application
- [ ] `GET /api/moderator/applications` - List pending applications (requires moderator role)
- [ ] `POST /api/moderator/applications/:id/approve` - Approve application
- [ ] `POST /api/moderator/applications/:id/reject` - Reject application

**User/Stats Endpoints**
- [ ] `GET /api/user/profile` - Get user's contribution stats
- [ ] `GET /api/user/contributions` - List user's submissions
- [ ] `GET /api/leaderboard` - Public contributor leaderboard

**Test Endpoints**
- [ ] `GET /api/moderator/test-questions` - Get the 10 test questions for moderator application

### Data Flow

**User Contribution Flow**
1. User clicks unconverted word
2. Modal opens with contribution form
3. User enters Traditional Mongolian (Latin transliteration)
4. User chooses: "Save locally only" OR "Save locally AND submit"
5. If local only:
   - Save to IndexedDB (user_dictionary table)
   - Close modal, word now converts for this user
6. If local + submit:
   - Save to IndexedDB (user_dictionary table)
   - POST to `/api/dictionary/word` with auth token (or anonymous)
   - Server saves to pending_submissions table
   - Close modal, word now converts for this user
7. Word remains in user's local dictionary even if later rejected by moderators

**Moderator Review Flow**
1. Moderator views pending submissions list
2. Clicks word to review (opens detail view with context)
3. Cannot see existing approval count or who submitted (blind review)
4. Moderator approves, rejects, or edits:
   - **Approve**: POST to `/api/moderation/word/:id/approve`
     - Server increments approval_count by +1
     - If count reaches +1 (first approval): status = probation
     - If count reaches +5: status = accepted
   - **Reject**: POST to `/api/moderation/word/:id/reject`
     - Server decrements approval_count by -1
     - If count reaches -3: status = rejected
   - **Edit**: PUT to `/api/moderation/word/:id/edit`
     - If editing Cyrillic: Creates new database entry
     - If editing Traditional Mongolian: Resets approval_count to +1
5. Word status updates in database
6. Next dictionary sync propagates changes to all users

**Dictionary Sync Flow**
1. PWA service worker checks for updates on app start or periodically
2. Calls `GET /api/dictionary/delta?since=<last_sync_timestamp>`
3. Server returns array of changed words (added, edited, status changed)
4. Service worker updates IndexedDB (shared_dictionary table)
5. If major version change detected:
   - Download full dictionary: `GET /api/dictionary/full?version=<new_version>`
   - Replace shared_dictionary table entirely
6. User receives subtle notification: "Dictionary updated with X new words"
7. Happens automatically in background (no user prompt)

**Conversion Flow (Client-Side)**
1. User enters Cyrillic text and clicks Convert
2. **Abbreviation Detection**: Regex finds all-caps multi-letter words
3. **Abbreviation Expansion**: For each detected abbreviation:
   - Check user_dictionary (IndexedDB) for expansion
   - If not found, check shared_dictionary (IndexedDB)
   - If not found, prompt user with modal
   - User provides expansion, optionally saves locally/submits
   - Replace abbreviation with expansion in text
4. **Word-by-Word Conversion**: Split text by whitespace
5. **Dictionary Lookup** for each word:
   - Check user_dictionary first (higher priority)
   - If not found, check shared_dictionary (status = probation or accepted only)
   - If found: Replace with Traditional Mongolian (Menksoft encoding)
   - If multiple variants exist: Prompt user with choice modal
   - If not found: Leave in Cyrillic, mark as unconverted (highlighted)
6. **Render Output**: Display converted text with Menksoft font
7. **Copy**: On copy button click, convert Menksoft to Unicode using provided algorithm

---

## Implementation Phases

### Phase 1: MVP Core (Weeks 1-4)
**Goal**: Basic conversion functionality with local-only contributions

- [ ] Frontend: Main conversion screen (input/output)
- [ ] Abbreviation detection and expansion (local storage)
- [ ] Dictionary lookup (IndexedDB, local only)
- [ ] Menksoft font rendering and Unicode conversion on copy
- [ ] Contribution modal (save locally only)
- [ ] On-screen keyboard (with placeholder mappings until provided)
- [ ] Seed database with 20-30K words (probation status)
- [ ] Basic PWA setup (service worker, offline caching)

**Deliverable**: Functional converter that works 100% offline, no server needed yet

### Phase 2: Backend & Authentication (Weeks 5-6)
**Goal**: Server integration and user accounts

- [ ] Dart Shelf API setup with Docker
- [ ] PocketBase integration for authentication
- [ ] PostgreSQL or PocketBase database schema
- [ ] API endpoints for dictionary sync (full + delta)
- [ ] API endpoints for word submission
- [ ] Frontend: Login/signup UI
- [ ] Frontend: "Save locally AND submit" option in contribution modal
- [ ] Frontend: Dictionary sync on app start
- [ ] Deploy to VPS

**Deliverable**: Users can create accounts and submit contributions to server

### Phase 3: Moderation System (Weeks 7-9)
**Goal**: Complete moderation workflow

- [ ] Moderator application form (test + self-description)
- [ ] API endpoints for moderator applications
- [ ] Moderator dashboard UI (pending, probation, accepted tabs)
- [ ] Review interface with context display
- [ ] Approve/reject/edit functionality
- [ ] Approval count tracking (net +5 = accepted, net -3 = rejected)
- [ ] Multi-variant support (one-to-many Cyrillic → Traditional Mongolian)
- [ ] Moderator application review interface

**Deliverable**: Complete moderation workflow from application to word approval

### Phase 4: User Experience Enhancements (Weeks 10-11)
**Goal**: Polish and usability improvements

- [ ] One-to-many choice dialog during conversion
- [ ] User profile page with statistics
- [ ] Contribution editing for users
- [ ] Public leaderboard
- [ ] Improved offline handling (queue submissions)
- [ ] Better sync indicators and notifications
- [ ] Accessibility audit and fixes
- [ ] Performance optimization (large dictionary handling)

**Deliverable**: Polished, user-friendly experience with full feature set

### Phase 5: Testing & Launch (Week 12)
**Goal**: Bug fixes, testing, and launch preparation

- [ ] Cross-browser testing (Chrome, Firefox, Safari, Edge)
- [ ] Mobile responsiveness testing
- [ ] Load testing (2M word dictionary simulation)
- [ ] Security audit
- [ ] Documentation (user guide, moderator guide)
- [ ] Onboarding flow for first-time users
- [ ] Beta testing with small group
- [ ] Bug fixes based on feedback

**Deliverable**: Production-ready application

## Features (MVP)
### Client-Side Conversion Engine
This is the core feature that executes the Cyrillic-to-Traditional Mongolian conversion directly in the user's browser. It prioritizes user privacy and provides an instantaneous, offline-first experience by using dictionaries stored locally and avoiding any server-side text processing.

#### Tech Involved
*   JavaScript (ESM)
*   IndexedDB API
*   Web Workers (Potential for large text to prevent UI blocking)
*   Service Worker (For PWA functionality)

#### Main Requirements
*   **Privacy-by-design**: Conversion logic must run entirely on the client, with no text ever being uploaded to a server.
*   **Offline-first**: The application must be fully functional without an internet connection once the dictionary is cached.
*   **Performance**: Conversions for substantial texts (e.g., 1000+ words) should feel instantaneous (<500ms).
*   **Accuracy**: The engine must correctly prioritize the user's local dictionary over the shared community dictionary during lookups.

### Dual-Layer Dictionary System
This system manages two distinct data sources for conversions: a private, user-specific dictionary and a larger, read-only community dictionary. User contributions are immediately saved to their local dictionary for personal use, while the community dictionary is periodically updated from the server, ensuring all users benefit from moderated, crowdsourced data.

#### Tech Involved
*   IndexedDB
*   Service Worker with Background Sync API
*   Fetch API

#### Main Requirements
*   **Immediate Local Benefit**: A user's new word/abbreviation contributions must be available to them for conversion instantly, even before moderation.
*   **Data Segregation**: The user's local dictionary and the shared community dictionary must be stored and queried separately.
*   **Efficient Syncing**: The PWA must handle an initial large dictionary download (~3MB) and subsequent smaller, incremental updates efficiently in the background without disrupting the user experience.
*   **Resilience**: The system must function correctly if a user remains offline for extended periods and then reconnects.

### Crowdsourcing & Moderation API
This is the backend service responsible for ingesting, managing, and serving all community-driven translation data. It handles user authentication for moderators, processes new word submissions, and enforces the multi-stage moderation workflow to ensure the quality of the shared dictionary.

#### Tech Involved
*   Dart Shelf (API Framework)
*   PostgreSQL (Primary Datastore)
*   PocketBase (Authentication & User Management)
*   Docker (Containerization)

#### Main Requirements
*   **Quality Control**: A rigorous, multi-tier approval system (net +5 for accepted, net -3 for rejected) is required to maintain dictionary integrity.
*   **Role-Based Access Control**: The API must securely differentiate between anonymous users, authenticated contributors, and trusted moderators.
*   **Scalability**: The database schema and API endpoints must be designed to handle millions of word pairs and thousands of concurrent users syncing data.
*   **Moderator Anonymity**: The system must support blind reviews where moderators cannot see the votes of other moderators to prevent bias.

## System Diagram
```mermaid
graph TD
    subgraph Client (Browser/PWA)
        UI[User Interface - HTML/CSS/JS]
        Engine[Conversion Engine]
        DB[IndexedDB]
        SW[Service Worker]
        
        UI -- User Input --> Engine
        Engine -- Dictionary Lookup --> DB
        UI -- Contribution --> DB
        UI -- Contribution for Review --> SW
        DB -- User & Community Dictionaries --> Engine
        SW -- Background Sync --> API
    end

    subgraph CDN (GitHub Pages / Cloudflare)
        Static[Static Assets - App Shell, Fonts]
    end

    subgraph Backend (VPS)
        API[API Server - Dart Shelf]
        Auth[Authentication - PocketBase]
        Database[(PostgreSQL)]
        
        API -- CRUD Operations --> Database
        API -- Verify Role --> Auth
        Moderator -- Moderation Actions --> API
    end

    User[User] -- Interacts With --> UI
    Moderator[Moderator] -- Manages Data --> UI
    User -- Initial Load --> CDN
    SW -- Caches --> Static
```

## List of Technical/Architecture Consideration Questions
*   **Frontend Framework Choice**: The spec mentions Vanilla JS or a lightweight framework. Given the complexity of state management (UI state, conversion choices, auth status, local/remote data), would a minimal framework like Svelte or Vue provide significant development velocity and maintainability advantages over Vanilla JS without a major performance trade-off?

That is fine to use something besides Vanilla JS. Whatever you think is best.

*   **Backend Stack Complexity**: The proposed backend uses Dart Shelf, PocketBase, and PostgreSQL. Was a more integrated "Backend-as-a-Service" like Supabase considered? Supabase uses PostgreSQL and could potentially consolidate the API and authentication layers, possibly simplifying deployment and maintenance. What are the key drivers for choosing the Dart Shelf + PocketBase combination?

I'd like to stick with Dart Shelf, PocketBase, and PostgreSQL because I am familiar with them and Supabase is maybe too expensive for me.

*   **Anonymous Contributions**: Hashing IP addresses is a good privacy measure. What is the strategy for preventing spam or low-quality anonymous submissions? Will there be stricter rate-limiting or a CAPTCHA-like mechanism for anonymous contributors?

That would be good to add rate limiting.



## Features List

### Core App Experience

#### Client-Side Conversion Engine
This is the heart of the app—the magic moment where the user's problem is solved instantly and privately. The entire experience should feel effortless, fast, and trustworthy.

-   **User Stories**
    -   **Alima (Language Learner):** *As a language learner, I want to paste a news article in Cyrillic and see the Traditional Mongolian script instantly, so that I can practice my reading without worrying about my text being stored on a server.*
    -   **Solongo (Content Creator):** *As a content creator, I want to convert text in real-time as I type, so that I can speed up my workflow without breaking my creative flow.*
    -   **Chen (Casual User):** *As a casual user, I want to use the converter without signing up or waiting, so that I can satisfy my curiosity about a few words and move on.*
    -   **Batbayar (Cultural Preservationist):** *As a preservationist dealing with sensitive texts, I want the entire conversion to happen on my machine, so that I can maintain absolute confidentiality of the documents I work with.*

-   **UX/UI Considerations**
    -   **Core Experience: The Conversion Flow**
        -   **Initial (Empty) State:** The user is greeted with a clean, two-panel layout (side-by-side on desktop, stacked on mobile). The left panel is the Cyrillic input, and the right is the Traditional Mongolian output. The input panel contains clear placeholder text: *"Та кирилл монгол бичвэрээ энд буулгана уу..."* (Paste your Cyrillic Mongolian text here...). A single, prominent "Convert" button is centrally located or clearly associated with the input. The output panel is empty, perhaps with a subtle logo or pattern to signify it's a target area.
        -   **Active Typing/Pasting State:** As the user types or pastes text into the input panel, a character/word count appears below the box, providing immediate feedback. The "Convert" button becomes fully active (e.g., color saturation increases). The output panel remains unchanged.
        -   **Converted State:** Upon clicking "Convert," the conversion is virtually instantaneous (<500ms). There is no loading spinner. The Traditional Mongolian text appears vertically in the output panel, rendered beautifully in the Menksoft font.
        -   **Visual Hierarchy:** The input text is secondary to the beautifully rendered, primary output. The most important elements are the text areas and the "Convert" button. Secondary actions like "Copy" and "Clear" are visible but less prominent (e.g., smaller icon buttons).
        -   **Unconverted Words:** Any word not found in either the local or community dictionary remains in Cyrillic but is visually highlighted in the output. A subtle but clear dotted red underline is a good starting point, signifying "unrecognized" without the alarming feel of a solid red error color. Hovering over the word could trigger a tooltip: "Click to add a translation." This transforms a point of failure into an opportunity for engagement.

    -   **Advanced Users & Edge Cases**
        -   **Large Text:** For exceptionally large texts that might cause a brief UI freeze (though unlikely with modern JS engines and optimized lookups), the "Convert" button could show a very brief loading state (e.g., a quick pulse animation) to reassure the user that the action was received. If this becomes a consistent issue, processing could be moved to a Web Worker to keep the UI perfectly smooth.
        -   **Offline State:** A subtle, non-intrusive indicator (e.g., a small cloud icon with a slash through it in the header) appears when the user is offline. The app remains 100% functional. The indicator's tooltip would read: "Offline mode. All conversions are using the locally saved dictionary."

#### Dual-Layer Dictionary System
This feature empowers users by giving them immediate value from their contributions while simultaneously enriching the community resource. The UX must clearly, if subtly, distinguish between the user's private dictionary and the shared public one.

-   **User Stories**
    -   **Alima (Language Learner):** *As a learner, I want to add a new slang term I just learned to my dictionary, so that it converts correctly for me immediately in my next session, even if the community hasn't approved it yet.*
    -   **Batbayar (Cultural Preservationist):** *As an expert, I want my specialized historical terms to be saved locally, so my documents convert accurately, but I also want to submit them to the community to improve the shared resource over time.*
    -   **Solongo (Content Creator):** *As a writer, I want the dictionary to automatically update in the background with new community-approved words, so that my conversions become more accurate over time without any effort on my part.*

-   **UX/UI Considerations**
    -   **Core Experience: Seamless Lookup**
        -   **The user's mental model should be simple: "The app just converts my text."** They don't need to know *which* dictionary is being used at any given moment. The `Local -> Community` lookup priority is an invisible implementation detail that simply makes the app feel smarter and more personalized.
        -   **Dictionary Updates:** When a background sync completes, a subtle, self-dismissing notification (a "toast") could appear at the bottom of the screen: "Dictionary updated with new community contributions." This reinforces the app's value and collaborative nature without interrupting the user's flow.
        -   **Information Architecture:** There is no explicit UI for "viewing" the two dictionaries separately in the main conversion flow. The distinction only becomes relevant during the contribution process.

    -   **Advanced Users & Edge Cases**
        -   **First-Time Use:** On first load, the app will need to download and cache the initial community dictionary. A lightweight progress indicator should be shown (e.g., "Downloading dictionary for offline use..."). This is a one-time cost that enables the powerful offline-first experience.
        -   **Conflicting Entries:** In the rare case where a user's local entry for a Cyrillic word differs from a community-approved one, the user's local version *always* wins. This is a core principle of the feature. There is no UI to resolve this conflict; the user's explicit choice is respected above all else.
        -   **Prolonged Offline Use:** If a user comes back online after a long time, the service worker will detect a significant version difference and may trigger a full dictionary download in the background. The app will continue to function with the older version until the new one is ready, at which point it will swap seamlessly.

### Crowdsourcing & Community

#### Contribution & Moderation
This is the engine of community growth. The contribution process must be as frictionless as possible, turning moments of "failure" (an unconverted word) into simple, rewarding interactions. The moderation workflow must be robust and efficient for our expert volunteers.

-   **User Stories**
    -   **Solongo (Content Creator):** *As a writer, when I see an unconverted word, I want a quick way to add its translation and context, so that I can fix it for myself and help the community without leaving my workflow.*
    -   **Chen (Casual User):** *As an anonymous user, I want to suggest a translation for a word I know without creating an account, so that I can make a small contribution easily.*
    -   **Ganbaatar (Moderator):** *As a moderator, I want to review new submissions in a clear, context-rich interface, so that I can make accurate judgments on their validity and maintain the quality of the shared dictionary.*
    -   **Alima (Language Learner):** *As a contributor, I want to track the status of my submissions, so I can see if my contributions are being accepted and helping others.*

-   **UX/UI Considerations**
    -   **Core Experience: The Contribution Modal**
        -   **Trigger:** User clicks on a highlighted, unconverted Cyrillic word in the output panel.
        -   **Modal UI:** A clean, focused modal appears.
            -   **Hierarchy:** The primary focus is the Latin input field for the Traditional Mongolian transliteration. A live preview of the Menksoft rendering appears directly below or beside it, providing instant feedback.
            -   **Context is King:** Above the input fields, in a slightly muted, read-only block, the context is displayed: `... [word before] **[target word]** [word after] ...`. This is crucial for moderators.
            -   **Progressive Disclosure:** An optional on-screen keyboard can be toggled for users unfamiliar with the Latin mapping. It's hidden by default to keep the interface clean.
            -   **Clear Actions:** Two clear choices are presented, perhaps as a segmented control: "Save Locally" and "Save & Submit to Community". "Save Locally" is the default to provide the quickest path to value for the user.
        -   **Feedback:** Upon submission, the modal closes and the word in the main output panel instantly updates to its newly translated form. A brief success toast confirms the action: "Saved to your personal dictionary!" or "Saved locally and submitted for review!"

    -   **Advanced Users & Edge Cases**
        -   **Anonymous Spam Prevention:** An anonymous user (like Chen) attempting to submit to the community will be subject to rate-limiting. If they exceed the limit (e.g., >10 submissions in an hour), the "Save & Submit to Community" option will be temporarily disabled. The UI will show a message: "Thank you for your contributions! To prevent spam, anonymous submissions are limited. Please try again later." They can still save unlimited words to their local dictionary.
        -   **Moderation Dashboard (For Ganbaatar):** This is a separate, protected area of the app.
            -   **Layout:** A clean, data-table-like view of pending submissions. Key information (Cyrillic word, context) is scannable.
            -   **Blind Review:** Crucially, the table does NOT show who submitted the word or what the current approval count is. This prevents bias.
            -   **Reviewing:** Clicking an entry opens a detail view that mirrors the contribution modal but with action buttons: "Approve," "Reject," and "Edit & Approve." The context is prominently displayed.
        -   **Editing a Submission:** If Alima logs in, goes to her profile, and edits one of her pending submissions, the approval count for that word on the backend is reset to zero. This ensures the newly edited version goes through a fresh review cycle.
-   


## A Functional UX/UI Style Guide

**To:** Project Stakeholders  
**From:** Lead Product Designer  
**RE:** Establishing a Scalable Design System for the Mongolian Script Converter  
**Date:** October 28, 2025

### A Note on Inspiration

This document outlines a functional design system based on the provided context and aesthetic guidelines. As the visual inspiration images were not available for analysis, this guide establishes a foundational system rooted in FANG-style best practices for high-touch SaaS applications. It is designed to be adaptable once specific aesthetic inspirations are incorporated.

***

### 1. Design Philosophy: The Principle of Instant Clarity

Our design system is governed by a single principle: **Instant Clarity**. Every component, interaction, and layout decision must serve to make the user's journey from Cyrillic input to Traditional Mongolian output feel effortless, trustworthy, and immediate.

We achieve this through a disciplined application of the following core concepts:

*   **Content-First Architecture:** The user's text is the hero. The UI is a minimal, elegant frame that elevates the content and removes all friction from the core conversion task.
*   **Cognitive Breathing Room:** We will aggressively use negative space to reduce cognitive load, guiding the user's focus naturally between input, action, and output. This ensures that even first-time users intuitively understand the interface without instruction.
*   **Purposeful Responsiveness:** The interface is not static; it is a conversation. Every user action will receive immediate, clear, and subtle feedback, from button state changes to micro-interactions, confirming system status and building trust.

This philosophy directly supports our core user stories, from the casual user (Chen) who wants a zero-friction experience to the preservationist (Batbayar) who requires a tool that feels professional and secure.

### 2. Color Palette

The color palette is designed for bold simplicity and accessibility. It uses a primary neutral family for the core interface, ensuring content is always the focus, complemented by a vibrant, single-action color and semantic accents for clear communication.

| Role                   | Color       | Hex Code  | Usage                                                                                       |
| :--------------------- | :---------- | :-------- | :------------------------------------------------------------------------------------------ |
| **Primary UI**         |             |           |                                                                                             |
| Background             | White       | `#FFFFFF` | Provides maximum breathing room and content contrast.                                       |
| Surface                | Off-White   | `#F9F9F9` | Used for contained elements like modals to gently separate them from the main background.   |
| Text (Primary)         | Near-Black  | `#1A1A1A` | Main text for readability; avoids the harshness of pure black.                              |
| Text (Secondary)       | Medium Gray | `#6B6B6B` | For placeholder text, helper text, and secondary information like character counts.         |
| Borders/Dividers       | Light Gray  | `#E0E0E0` | Subtle structural lines.                                                                    |
| **Action & Accent**    |             |           |                                                                                             |
| Primary Action         | Royal Blue  | `#0052FF` | The core "Convert" button and primary interactive elements. A vibrant, trustworthy hue.     |
| Primary Action (Hover) | Bright Blue | `#0048E0` | Provides clear feedback on interactive elements.                                            |
| **Semantic**           |             |           |                                                                                             |
| Success                | Green       | `#28A745` | Confirmation toasts (e.g., "Saved successfully!").                                          |
| Information            | Muted Blue  | `#007BFF` | Informational toasts (e.g., "Dictionary updated.").                                         |
| Warning/Error          | Red         | `#DC3545` | Used *exclusively* for the subtle underline on unconverted words and critical error states. |

### 3. Typography

The typographic hierarchy is designed for scannability and clarity, creating a clear information structure that guides the user's eye without effort. We will utilize a single, versatile sans-serif font family for the UI and the specified `Menksoft` font for the output.

**UI Font Family:** Inter (or a similar neutral, highly legible sans-serif)

| Element           | Font Weight | Size (Desktop / Mobile) | Line Height | Use Case                                                           |
| :---------------- | :---------- | :---------------------- | :---------- | :----------------------------------------------------------------- |
| **Display Title** | Medium      | `24px / 20px`           | 1.2         | Main heading in modals (e.g., "Add to Dictionary").                |
| **Text Area**     | Regular     | `18px / 16px`           | 1.6         | Cyrillic input text. Designed for comfortable reading and writing. |
| **Button**        | Medium      | `16px / 16px`           | 1           | All button labels.                                                 |
| **Body / Label**  | Regular     | `14px / 14px`           | 1.5         | Helper text, captions, context snippets in the modal.              |
| **Toast Message** | Regular     | `14px / 14px`           | 1.4         | Notification text.                                                 |

**Traditional Mongolian Output Font:** Menksoft (or specified font)
*   **Rendering:** Text will be rendered vertically with appropriate character spacing to ensure beautiful and accurate representation. Font size will be proportional to the Cyrillic input to maintain visual harmony.

### 4. Grid & Spacing

A consistent spacing system based on an **8pt grid** will be used to ensure rhythmic, visually pleasing layouts. This systematic approach to spacing is critical for creating "breathable whitespace" and reducing visual clutter.

*   **Base Unit:** `1rem = 16px`
*   **Core Spacing Values (Multiples of 8):**
    *   `x-small (4px)`: Gaps between icons and text.
    *   `small (8px)`: Padding within small components like icon buttons.
    *   `medium (16px)`: Padding within larger components (buttons, text inputs), gaps between related items.
    *   `large (24px)`: Gaps between distinct UI sections (e.g., input panel and button).
    *   `x-large (32px)`: Padding around the main conversion container.
    *   `xx-large (48px)`: Major layout divisions.

### 5. Core Components

This section defines the building blocks of the interface, ensuring consistency and predictability.

#### **Buttons**

*   **Primary Action ("Convert")**
    *   **Style:** Solid fill with the `Primary Action` color. High contrast white text.
    *   **Size:** Large, with generous `medium (16px)` vertical and `x-large (32px)` horizontal padding to create an unmissable target.
    *   **States:**
        *   **Default:** Solid `#0052FF`.
        *   **Hover:** Darkens slightly to `#0048E0` with a subtle "lift" shadow.
        *   **Active/Pressed:** Darker `#003ECC`.
        *   **Disabled:** Light gray fill `#E0E0E0` with `Medium Gray` text. Non-interactive.

*   **Secondary Actions ("Copy," "Clear")**
    *   **Style:** Ghost button style. Transparent background with a `1px` solid `Light Gray` border and `Primary Action` colored text.
    *   **States:**
        *   **Hover:** Background subtly fills with a very light tint of the `Primary Action` color.
        *   **Active/Pressed:** Background fill becomes more pronounced.

#### **Text Panels (Input & Output)**

*   **Layout:** Side-by-side on desktop/tablet, stacked vertically on mobile. A `large (24px)` gap separates them.
*   **Style:** A generous `medium (16px)` internal padding. A subtle `1px` `Light Gray` border. On focus, the border color changes to `Primary Action` blue.
*   **Input (Empty State):** Displays placeholder text in `Secondary Text` color: *"Та кирилл монгол бичвэрээ энд буулгана уу..."*
*   **Output (Converted State):**
    *   **Unconverted Words:** Remain in Cyrillic script but are styled with a `2px` dotted underline of `Warning/Error` red. This avoids the alarming feel of a solid underline while clearly indicating an actionable item.
    *   **Tooltip on Hover:** On hovering an unconverted word, a small tooltip appears: *"Click to add a translation."*

#### **Contribution Modal**

*   **Appearance:** Appears with a gentle physics-based scale-in animation, centered on the screen. A semi-transparent overlay darkens the background to focus the user.
*   **Layout (Content-First):**
    1.  **Context Snippet:** At the top, in a muted block with `Secondary Text` color.
    2.  **Primary Input:** Large, focused input field for Traditional Mongolian transliteration.
    3.  **Live Preview:** Rendered Menksoft text appears instantly below the input.
    4.  **Actions:** A segmented control for "Save Locally" (default) and "Save & Submit to Community."

#### **Notifications (Toasts)**

*   **Appearance:** A small, rounded rectangle that slides up from the bottom of the screen. It remains for 3-4 seconds before gently sliding out.
*   **Style:** Uses the appropriate semantic color (`Success` or `Information`) with high-contrast text.

### 6. Motion & Animation

Motion is used sparingly and purposefully to enhance the user's understanding of the interface and provide feedback. All animations will be **physics-based (springs)** rather than duration-based, creating a more natural and fluid feel.

*   **State Transitions:** Changes in button states (hover, press) will have a subtle, quick transition on color and shadow properties. This makes the UI feel responsive and alive.
*   **Modal Appearance:** The contribution modal will not simply "appear." It will animate in with a gentle spring, giving it a sense of physical presence.
*   **Feedback Micro-interactions:** For large text conversions, the "Convert" button will perform a single, quick "pulse" animation upon click to acknowledge the input, even if the conversion is instantaneous. This reassures the user their action was received.

### 7. Accessibility

Accessibility is a core requirement, not an afterthought. The design system must ensure universal usability.

*   **Contrast Ratios:** All text and UI components will adhere to WCAG AA standards for color contrast, ensuring readability for users with visual impairments.
*   **Focus States:** All interactive elements (buttons, inputs, links) will have a clear and highly visible focus state (e.g., the `Primary Action` blue ring) for keyboard-only navigation.
*   **Target Sizes:** Tap targets on mobile will be a minimum of `48x48px` to accommodate imprecise touch interactions and prevent "fat-finger" errors.
*   **Alternative Text:** All icons that convey meaning will have appropriate text alternatives for screen reader users.
*   

# Cyrillic-Traditional Mongolian Converter Technical Specification

## 1. Executive Summary
- **Project overview and objectives**: This document outlines the technical specifications for a privacy-first, offline-capable Progressive Web App (PWA) that converts Cyrillic Mongolian text to Traditional Mongolian script. The core objectives are to provide instant, client-side conversion, empower the community through a crowdsourced dictionary with a robust moderation system, and ensure a seamless user experience on both desktop and mobile platforms.
- **Key technical decisions and rationale**:
    - **Client-Side Conversion**: All text processing occurs in the browser using JavaScript and IndexedDB. This guarantees user privacy as no sensitive text is ever sent to a server.
    - **Dual-Layer Dictionary**: A user's local IndexedDB dictionary is prioritized over the shared community dictionary. This allows users' contributions to be immediately useful to them, even before community moderation.
    - **PWA with Service Workers**: This enables a full offline-first experience and efficient background synchronization of the community dictionary.
    - **Hybrid Backend**: PocketBase is used for authentication and user management due to its simplicity and robust feature set. A custom Dart Shelf API backed by PostgreSQL is used for the complex logic of dictionary submissions and moderation, providing performance and scalability.
- **High-level architecture diagram**:
```mermaid
graph TD
    subgraph Client (Browser/PWA)
        UI[User Interface - React/Svelte/Vue]
        Engine[Conversion Engine - JS]
        LocalDB[IndexedDB]
        SW[Service Worker]

        UI -- User Input --> Engine
        Engine -- Dictionary Lookup --> LocalDB
        UI -- Contributions --> LocalDB
        UI -- Server Submissions --> SW
        LocalDB -- User & Community Dictionaries --> Engine
        SW -- Background Sync --> API
    end

    subgraph CDN (GitHub Pages / Cloudflare)
        Static[Static Assets - App Shell, Fonts]
    end

    subgraph Backend (VPS with Docker)
        API[API Server - Dart Shelf]
        Auth[Authentication - PocketBase]
        Database[(PostgreSQL)]

        API -- CRUD Operations --> Database
        API -- Verify Role --> Auth
        Moderator -- Moderation Actions --> API
    end

    User[User] -- Interacts With --> UI
    Moderator[Moderator] -- Manages Data --> UI
    User -- Initial Load --> CDN
    SW -- Caches --> Static
```
- **Technology stack recommendations**:
    - **Frontend**: Lightweight JavaScript framework (e.g., Svelte or Vue) for reactive UI, Vite for build tooling.
    - **Client-Side Storage**: IndexedDB for storing user and community dictionaries.
    - **Backend API**: Dart with the Shelf framework, running in a Docker container.
    - **Authentication**: Self-hosted PocketBase instance.
    - **Database**: PostgreSQL for the community dictionary and moderation data.
    - **Hosting**: GitHub Pages with Cloudflare for the frontend PWA, and a VPS (e.g., DigitalOcean, Hetzner) for the backend Docker containers.

## 2. System Architecture
### 2.1 Architecture Overview
- **System components and their relationships**:
    - **Frontend PWA**: The single-page application that users interact with. It contains all the UI, the client-side conversion logic, and manages the local dictionaries in IndexedDB.
    - **Service Worker**: A script that runs in the background, enabling offline functionality, caching of the application shell, and handling background synchronization of the community dictionary with the backend API.
    - **Backend API (Dart Shelf)**: A stateless API responsible for ingesting new word contributions, managing the moderation workflow, and serving dictionary updates to clients.
    - **Authentication Service (PocketBase)**: Manages user registration, login, and roles (e.g., "user," "moderator"). It issues JWTs that the Dart API validates for protected endpoints.
    - **Database (PostgreSQL)**: The source of truth for all community-contributed words, abbreviations, user data (via PocketBase), and moderation logs.
- **Data flow diagrams**:
    - **Conversion Flow (Client-Side Only)**:
      ```mermaid
      sequenceDiagram
          participant User
          participant UI
          participant ConversionEngine
          participant IndexedDB

          User->>UI: Enters Cyrillic text & Clicks "Convert"
          UI->>ConversionEngine: Initiate conversion with text
          ConversionEngine->>ConversionEngine: Detect & Expand Abbreviations (lookup in IndexedDB)
          ConversionEngine->>IndexedDB: Lookup each word (Local Dict first)
          IndexedDB-->>ConversionEngine: Return Traditional Mongolian or null
          ConversionEngine->>IndexedDB: Lookup in Community Dict if not in Local
          IndexedDB-->>ConversionEngine: Return Traditional Mongolian or null
          ConversionEngine-->>UI: Return converted text with unconverted words highlighted
          UI->>User: Display result
      ```
    - **Contribution Sync Flow**:
      ```mermaid
      sequenceDiagram
          participant User
          participant UI
          participant IndexedDB
          participant ServiceWorker
          participant API

          User->>UI: Submits new word (Save & Submit)
          UI->>IndexedDB: Save word to Local Dictionary (immediate use)
          UI->>ServiceWorker: Queue submission for server
          ServiceWorker->>API: POST /api/dictionary/word (with auth token)
          API->>API: Validate data & user role
          API->>Database: Insert new word with 'pending' status
          API-->>ServiceWorker: Return success
      ```
- **Infrastructure requirements**:
    - **CDN**: A global CDN like Cloudflare for low-latency delivery of frontend static assets.
    - **VPS**: A virtual private server with Docker support to host the Dart Shelf API, PocketBase, and PostgreSQL database. Recommended minimum: 2 vCPU, 4GB RAM.
    - **Domain Name**: A custom domain name for the application.

### 2.2 Technology Stack
- **Frontend technologies and frameworks**:
    - **Framework**: SvelteKit or Vue.js. Chosen for their performance, small bundle sizes, and excellent developer experience, which are ideal for a PWA.
    - **Styling**: Tailwind CSS for a utility-first approach to building a responsive and consistent UI.
    - **State Management**: Svelte Stores or Pinia for managing global UI state like authentication status and dictionary sync progress.
- **Backend technologies and frameworks**:
    - **API**: Dart 3+ with the Shelf framework.
    - **Authentication**: PocketBase (self-hosted).
    - **Containerization**: Docker and Docker Compose for creating reproducible environments for the API, database, and auth service.
- **Database and storage solutions**:
    - **Client-Side**: IndexedDB for storing the local user dictionary and the cached community dictionary.
    - **Server-Side**: PostgreSQL 15+ for its robustness, reliability, and powerful querying capabilities for relational data.
- **Third-party services and APIs**: None. The architecture is self-contained to ensure low cost and high control.

## 3. Feature Specifications
### 3.1 Core Conversion & Contribution
- **User stories and acceptance criteria**:
    - **As a user, I can paste Cyrillic text and convert it instantly to see the Traditional Mongolian script.**
        - AC1: The conversion must happen entirely client-side.
        - AC2: For text up to 1000 words, the conversion must complete in under 500ms.
        - AC3: Words not found in any dictionary remain in Cyrillic and are visually highlighted with a red dotted underline.
    - **As a user, I can click on an unconverted word to add its translation.**
        - AC1: Clicking an unconverted word opens a modal.
        - AC2: The modal displays the word and its surrounding context (2 words before/after).
        - AC3: The user can input a Latin transliteration which is live-previewed in Menksoft script.
    - **As a user, my new contributions are available for my own use immediately.**
        - AC1: Saving a new word (either "locally only" or "locally and submit") adds it to the user's local IndexedDB dictionary.
        - AC2: The word in the main text output is immediately updated upon saving.
- **Technical requirements and constraints**:
    - The Menksoft-to-Unicode conversion algorithm must be implemented in JavaScript and executed on the copy-to-clipboard action.
    - Abbreviation detection logic (`/\b[A-Z-]{2,}\b/g`) runs before the main word-by-word conversion.
    - Dictionary lookups must be case-insensitive for Cyrillic keys.
- **Detailed implementation approach**:
    1.  On app load, the `CommunityDictionary` and `UserDictionary` are loaded from IndexedDB into in-memory JavaScript `Map` objects for fastest lookup performance.
    2.  When the "Convert" button is clicked, the input text is first processed by an abbreviation expansion function. This function iterates through detected abbreviations, looks them up in the `UserDictionary` map then the `CommunityDictionary` map, and replaces them. If an abbreviation is not found, a modal is triggered.
    3.  The text is then split into words and punctuation. Each word is looked up, first in `UserDictionary`, then in `CommunityDictionary`.
    4.  If a word has multiple translations, a modal is triggered, and the user's choice is used for all instances in the current session.
    5.  Unconverted words are wrapped in a `<span>` with a specific class for styling and a `data-word` attribute to identify them.
    6.  Event listeners are attached to these spans to trigger the contribution modal.
- **User flow diagrams**:
  ```mermaid
  graph TD
      A[User pastes text and clicks Convert] --> B{Abbreviation Found?};
      B -- Yes --> C{In Dictionary?};
      C -- Yes --> D[Replace with expansion];
      C -- No --> E[Show Abbreviation Modal];
      E --> F{User provides expansion};
      F -- Save --> D;
      F -- Skip --> G;
      B -- No --> G[Split text into words];
      G --> H{Word in User Dictionary?};
      H -- Yes --> I[Use local translation];
      H -- No --> J{Word in Community Dictionary?};
      J -- Yes --> K{Multiple Translations?};
      K -- Yes --> L[Show Choice Modal];
      L --> M[Use selected translation];
      K -- No --> N[Use community translation];
      J -- No --> O[Highlight as unconverted];
      I & M & N & O --> P[Render final output];
  ```
- **API endpoints (if applicable)**:
    - `POST /api/dictionary/word`
    - `POST /api/dictionary/abbreviation`
- **Data models involved**:
    - `WordConversionPairs`
    - `AbbreviationExpansions`
- **Error handling and edge cases**:
    - **Offline Submission**: If a user tries to "Save & Submit" while offline, the submission is saved to the local dictionary, and the UI displays a message: "You're offline. Word saved locally. It will be submitted when you're back online." The submission can be queued using the Service Worker's Background Sync API.
    - **Large Text**: For text exceeding 5000 words, the conversion logic can be offloaded to a Web Worker to prevent blocking the main UI thread. A subtle loading indicator will be shown.
- **Performance considerations**: Using `Map` objects for in-memory dictionary lookups provides O(1) average time complexity, which is critical for near-instant conversion.

### 3.2 User Authentication & Moderation
- **User stories and acceptance criteria**:
    - **As a logged-in user, I can apply to become a moderator by passing a test.**
        - AC1: The application form includes a 10-question test.
        - AC2: The user must score at least 9/10 to be able to submit the application.
        - AC3: The application is submitted to a queue for review by existing moderators.
    - **As a moderator, I can review pending submissions and approve or reject them.**
        - AC1: The moderation dashboard lists pending submissions with their context.
        - AC2: The review is blind; the contributor and other moderators' votes are not visible.
        - AC3: An approval adds +1 to a word's score, a rejection adds -1.
    - **As a moderator, I can review moderator applications and approve or reject them.**
        - AC1: The application review interface shows the applicant's test score, answers, and self-description.
        - AC2: Approving an applicant assigns them the 'moderator' role in PocketBase.
- **Technical requirements and constraints**:
    - All moderation endpoints must be protected and require a valid JWT from a user with the 'moderator' role.
    - The moderation test questions should be fetched from a secure endpoint and not be hardcoded in the frontend to prevent cheating.
- **Detailed implementation approach**:
    - Authentication is handled by the PocketBase Web SDK. On login, a JWT is stored securely (e.g., in a httpOnly cookie if server-side rendering is used, or in memory for a pure SPA).
    - The JWT is sent in the `Authorization` header for all requests to the Dart Shelf API.
    - The Dart API uses a middleware to intercept requests to protected routes. It validates the JWT against PocketBase's public key or via an API call to PocketBase to verify the token and check the user's roles.
    - The moderation system logic (approval counts, status changes) is handled entirely on the backend to maintain integrity.
        - `approval_count` reaches `1`: `status` becomes `'probation'`.
        - `approval_count` reaches `5`: `status` becomes `'accepted'`.
        - `approval_count` reaches `-3`: `status` becomes `'rejected'`.
- **API endpoints (if applicable)**:
    - `GET /api/moderator/test-questions`
    - `POST /api/moderator/apply`
    - `GET /api/moderation/pending`
    - `POST /api/moderation/word/:id/approve`
    - `POST /api/moderation/word/:id/reject`
- **Data models involved**:
    - `Users` (PocketBase)
    - `ModeratorApplications`
    - `ModeratorActions`
    - `WordConversionPairs`
- **Error handling and edge cases**:
    - **Race Conditions**: If two moderators act on the same word simultaneously, the database transaction will handle the updates sequentially. The backend will use `SELECT FOR UPDATE` if necessary to lock the row during the update transaction to prevent race conditions on the `approval_count`.
    - **Unauthorized Access**: The API will return a `403 Forbidden` status code if a non-moderator attempts to access moderation endpoints.

## 4. Data Architecture
### 4.1 Data Models
- **WordConversionPairs**: Stores the core translation data.
    - `word_id` (BIGSERIAL, PRIMARY KEY)
    - `cyrillic_word` (TEXT, NOT NULL, INDEX)
    - `traditional_mongolian_menksoft` (TEXT, NOT NULL)
    - `traditional_mongolian_latin` (TEXT, NOT NULL)
    - `context_before` (TEXT)
    - `context_after` (TEXT)
    - `status` (VARCHAR(10), NOT NULL, DEFAULT 'pending', INDEX) - Values: 'pending', 'probation', 'accepted', 'rejected'
    - `approval_count` (INTEGER, NOT NULL, DEFAULT 0, INDEX)
    - `contributor_id` (VARCHAR(30), NULL) - Foreign key to PocketBase users table ID
    - `contributor_ip_hash` (VARCHAR(64), NULL)
    - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
    - `updated_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
- **AbbreviationExpansions**: Stores abbreviation definitions.
    - `abbreviation_id` (BIGSERIAL, PRIMARY KEY)
    - `abbreviation` (TEXT, NOT NULL, INDEX)
    - `expansion` (TEXT, NOT NULL)
    - `status`, `approval_count`, etc. (same as `WordConversionPairs`)
- **ModeratorActions**: Logs every moderation action for auditing.
    - `action_id` (BIGSERIAL, PRIMARY KEY)
    - `word_id` (BIGINT, NULL, FOREIGN KEY REFERENCES WordConversionPairs(word_id))
    - `abbreviation_id` (BIGINT, NULL, FOREIGN KEY REFERENCES AbbreviationExpansions(abbreviation_id))
    - `moderator_id` (VARCHAR(30), NOT NULL) - Foreign key to PocketBase users table ID
    - `action_type` (VARCHAR(10), NOT NULL) - Values: 'approve', 'reject', 'edit'
    - `timestamp` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
- **Users**: Managed by PocketBase. Custom fields:
    - `is_moderator` (BOOLEAN, DEFAULT false)
- **ModeratorApplications**: Tracks applications to become a moderator.
    - `application_id` (SERIAL, PRIMARY KEY)
    - `user_id` (VARCHAR(30), NOT NULL)
    - `test_score` (INTEGER, NOT NULL)
    - `test_answers` (JSONB)
    - `self_description` (TEXT)
    - `status` (VARCHAR(10), NOT NULL, DEFAULT 'pending') - Values: 'pending', 'approved', 'rejected'
    - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())

### 4.2 Data Storage
- **Database selection and rationale**:
    - **PostgreSQL**: Chosen for its robustness, support for advanced indexing (e.g., GIN indexes for text search), and JSONB data type, making it ideal for the structured and auditable data required by the moderation system.
    - **IndexedDB**: The standard browser API for persistent client-side storage, necessary for the PWA's offline capabilities and for storing the large dictionary files without blocking the main thread.
- **Data persistence strategies**:
    - **Client**: Two IndexedDB object stores: `userDictionary` (keyed by `cyrillic_word`) and `communityDictionary` (keyed by `cyrillic_word`).
    - **Server**: All data is persisted in PostgreSQL.
- **Caching mechanisms**:
    - **Client**: The entire community dictionary (probation and accepted words) is downloaded, gzipped, and stored in IndexedDB. The Service Worker caches the app shell and static assets for instant loading.
    - **Server**: The gzipped full dictionary file can be pre-generated and cached on the server's filesystem or in a Redis cache to avoid generating it on every request.
- **Backup and recovery procedures**:
    - The PostgreSQL database will be backed up daily using `pg_dump`. Backups will be stored in a secure, off-site location (e.g., S3-compatible object storage).
    - Point-in-time recovery (PITR) will be configured to allow for restoration to any point within the last 7 days.

## 5. API Specifications
### 5.1 Internal APIs
- **Endpoint**: `POST /api/dictionary/word`
    - **Description**: Submit a new word or abbreviation contribution.
    - **Auth**: Optional (can be anonymous).
    - **Request Body Schema**:
      ```json
      {
        "cyrillic_word": "Монгол",
        "traditional_mongolian_latin": "monggol",
        "context_before": "Би бол",
        "context_after": "хүн."
      }
      ```
    - **Response Schema (201 Created)**:
      ```json
      {
        "status": "success",
        "message": "Contribution received and is pending review."
      }
      ```
    - **Rate Limiting**: 10 submissions per hour per IP address for anonymous users; 60 per hour for authenticated users.

- **Endpoint**: `GET /api/dictionary/full`
    - **Description**: Download the complete, gzipped community dictionary.
    - **Auth**: None.
    - **Request Parameters**: `?version=<string>` (optional, for cache busting).
    - **Response**: A `application/gzip` file containing a JSON array of word pairs.
      ```json
      [{ "c": "Монгол", "t": "monggol_menksoft_encoding" }, ...]
      ```
    - **Rate Limiting**: 5 requests per hour per IP.

- **Endpoint**: `POST /api/moderation/word/{id}/approve`
    - **Description**: A moderator approves a word.
    - **Auth**: Required (moderator role).
    - **Request Body Schema**: None.
    - **Response Schema (200 OK)**:
      ```json
      {
        "word_id": 12345,
        "new_approval_count": 1,
        "new_status": "probation"
      }
      ```
    - **Rate Limiting**: 200 actions per hour per moderator.

### 5.2 External Integrations
- This project has no external service integrations beyond the self-hosted PocketBase instance for authentication. Communication between the Dart API and PocketBase will be via PocketBase's REST API for user/role verification if needed.

## 6. Security & Privacy
### 6.1 Authentication & Authorization
- **Authentication mechanism and flow**:
    1. User signs up/logs in via the PocketBase SDK on the frontend.
    2. PocketBase returns a JWT.
    3. The frontend stores this JWT and includes it as a Bearer token in the `Authorization` header for all requests to the Dart API.
- **Authorization strategies and role definitions**:
    - **Anonymous**: Can convert text, download the dictionary, and submit contributions (with stricter rate limits).
    - **Authenticated User**: Can do everything an anonymous user can, plus apply for moderation, and view their contribution history.
    - **Moderator**: Can do everything an authenticated user can, plus access the moderation dashboard to approve/reject words and moderator applications. This is controlled by the `is_moderator` boolean flag in the PocketBase `users` collection. The Dart API verifies this role on every protected endpoint.
- **Session management**: Handled by the PocketBase SDK, which manages token storage and refresh.

### 6.2 Data Security
- **Encryption strategies**:
    - **In Transit**: All communication between the client, CDN, and backend servers will be encrypted using TLS 1.2 or higher (HTTPS).
    - **At Rest**: User passwords are automatically hashed by PocketBase. The PostgreSQL database will be configured on an encrypted filesystem.
- **PII handling and protection**:
    - The only PII collected for anonymous users is the IP address, which will be hashed using SHA-256 before being stored in the `contributor_ip_hash` field. Raw IP addresses will not be stored.
- **Compliance requirements**: While not strictly bound by GDPR/CCPA for this project, best practices will be followed. A privacy policy will clearly state what data is collected and why.

### 6.3 Application Security
- **Input validation and sanitization**: All user-submitted text (contributions, moderator applications) will be sanitized on the backend before being inserted into the database to prevent XSS attacks. The frontend will also escape any rendered user-generated content.
- **OWASP compliance measures**:
    - **Injection**: All database queries will use parameterized statements to prevent SQL injection.
    - **Broken Authentication**: JWTs will have a short expiration time and be handled by the robust PocketBase library.
    - **Security Misconfiguration**: Strict CORS policies will be enforced on the backend API. Security headers like `Content-Security-Policy` and `X-Content-Type-Options` will be implemented.

## 7. User Interface Specifications
This section is based on the "Functional UX/UI Style Guide" provided in the project request.

### 7.1 Design System
- **Visual design principles**: The design is governed by the principle of **Instant Clarity**. The UI is minimal and content-first, using generous whitespace to reduce cognitive load and guide the user.
- **Component library structure**: A flat component structure will be used, organized by function (e.g., `/components/layout`, `/components/forms`, `/components/conversion`).
- **Responsive design approach**: A mobile-first approach will be used. The layout will be a single stacked column on mobile and transition to a two-column layout on larger screens (tablets and desktops) using Tailwind CSS breakpoints.
- **Accessibility standards**: WCAG 2.1 AA compliance is the minimum target.

### 7.2 Design Foundations
#### 7.2.1 Color System
- **Primary**: White (`#FFFFFF`), Off-White (`#F9F9F9`)
- **Text**: Near-Black (`#1A1A1A`), Medium Gray (`#6B6B6B`)
- **Accent/Action**: Royal Blue (`#0052FF`)
- **Semantic**: Green (`#28A745` for success), Red (`#DC3545` for unconverted words/errors)

#### 7.2.2 Typography
- **UI Font**: Inter (sans-serif)
- **Output Font**: Menksoft
- **Type Scale**: Display Title (`24px`), Text Area (`18px`), Button (`16px`), Body (`14px`). Mobile sizes are slightly reduced.

#### 7.2.3 Spacing & Layout
- **Base unit system**: 8pt grid system. All spacing and sizing will be in multiples of 8px (e.g., `8px`, `16px`, `24px`, `32px`).
- **Breakpoints**: Mobile (<768px), Tablet (768px - 1024px), Desktop (>1024px).

#### 7.2.4 Interactive Elements
- **Button styles**:
    - **Primary**: Solid Royal Blue fill, white text. Darkens on hover.
    - **Secondary**: Transparent background, light gray border, blue text. Fills with a light blue tint on hover.
- **States**: All interactive elements will have distinct `default`, `hover`, `active/pressed`, and `disabled` states. Focus states will use a visible blue ring for accessibility.

### 7.3 User Experience Flows
- **Key user journeys with wireframes/mockups**:
    - **Main Conversion Flow**:
        - Empty State: Two panels, input on left, output on right. Clear call-to-action "Convert" button.
        - Converted State: Traditional Mongolian text appears vertically in the output panel. Unconverted words have a red dotted underline. "Copy" and "Clear" buttons are active.
    - **Contribution Flow**:
        ```mermaid
        graph TD
            A[User clicks red-underlined word] --> B(Contribution Modal Appears);
            B -- Shows --> C[Context Snippet];
            B -- Contains --> D[Latin Input Field & Live Preview];
            B -- Contains --> E[Save Options: Local / Local+Submit];
            D -- User types --> D;
            E -- User selects & clicks Save --> F{Is Online?};
            F -- Yes --> G[Save locally & submit to API];
            F -- No --> H[Save locally & queue submission];
            G & H --> I(Modal Closes);
            I --> J[Word in main UI updates instantly];
        ```

## 8. Infrastructure & Deployment
### 8.1 Infrastructure Requirements
- **Hosting environment**:
    - **Frontend**: Static hosting provider (GitHub Pages).
    - **Backend**: VPS running Docker.
- **Server requirements**:
    - Docker and Docker Compose installed.
    - Nginx or Caddy as a reverse proxy to handle SSL termination and route traffic to the appropriate containers (Dart API, PocketBase).
- **Network architecture**: The reverse proxy will be the only public-facing service. It will route `/api/*` requests to the Dart container and `/pb/*` requests to the PocketBase container. The PostgreSQL database will only be accessible from within the Docker network.

### 8.2 Deployment Strategy
- **CI/CD pipeline configuration**:
    - **Frontend**: A GitHub Action will be triggered on pushes to the `main` branch. It will build the Svelte/Vue application, run tests, and deploy the static assets to the `gh-pages` branch.
    - **Backend**: A separate GitHub Action will be triggered for the backend repository. It will build the Dart application into a Docker image, run tests, and push the image to Docker Hub.
- **Environment management**:
    - **Development**: Developers run all services locally using Docker Compose.
    - **Staging**: (Optional but recommended) A separate VPS to test new features before production.
    - **Production**: The main public-facing VPS.
- **Deployment procedures and rollback strategies**:
    - To deploy a new backend version, a script on the production VPS will run `docker-compose pull` to fetch the new image from Docker Hub and then `docker-compose up -d` to restart the services with the new image.
    - **Rollback**: If a deployment fails, the previous Docker image tag can be manually specified in the `docker-compose.yml` file and the services can be redeployed. Database migrations will have corresponding rollback scripts.

## 1. Project Setup: Backend Infrastructure
- [ ] Step 1: Initialize Backend Services with Docker Compose
  - **Task**: Create a `docker-compose.yml` file to define and configure the three core backend services: the Dart API (`api`), PostgreSQL (`db`), and PocketBase (`auth`). This setup ensures all backend components can be started with a single command.
  - **Files**:
    - `backend/docker-compose.yml`: Define services for `api`, `db`, and `auth`. Configure ports, volumes for data persistence, and environment variables for PostgreSQL and PocketBase credentials.
    - `backend/api/Dockerfile`: Create a Dockerfile for the Dart Shelf application. This will be a multi-stage build, starting from the Dart SDK to build the application, then copying the compiled output to a lean runtime image.
    - `backend/.env`: Store sensitive information like database passwords and JWT secrets, which will be loaded by Docker Compose.
  - **Step Dependencies**: None
  - **User Instructions**: Run `docker-compose up -d` from the `backend` directory to build and start all services. Verify that the containers are running using `docker ps`.

- [ ] Step 2: Initialize PostgreSQL Database Schema
  - **Task**: Create an initial SQL script that defines the schema for all required tables (`WordConversionPairs`, `AbbreviationExpansions`, `ModeratorActions`, `ModeratorApplications`). This script will be automatically executed by PostgreSQL upon its first initialization, setting up the database structure.
  - **Files**:
    - `backend/db/init.sql`: Write `CREATE TABLE` statements for the four main tables, including primary keys, foreign keys, indexes, and default values as specified in the "Data Models" section of the technical specification.
    - `backend/docker-compose.yml`: Modify the `db` service definition to mount the `init.sql` script to `/docker-entrypoint-initdb.d/init.sql`. This is the standard mechanism for initializing a PostgreSQL container.
  - **Step Dependencies**: Step 1
  - **User Instructions**: If Step 1 was already run, you will need to stop the containers (`docker-compose down`), remove the PostgreSQL volume to allow re-initialization (`docker volume rm backend_db-data`), and then run `docker-compose up -d` again.

- [ ] Step 3: Scaffold Dart Shelf API and Health Check Endpoint
  - **Task**: Create a basic Dart Shelf application. This includes setting up the project structure, adding dependencies, and creating a simple health-check endpoint (e.g., `GET /ping`) to verify that the API server is running correctly inside its Docker container.
  - **Files**:
    - `backend/api/pubspec.yaml`: Define project metadata and add dependencies like `shelf` and `shelf_router`.
    - `backend/api/bin/server.dart`: The main entry point for the application. It will initialize a Shelf server and listen on the configured port.
    - `backend/api/lib/api_router.dart`: Create a simple router with a `/ping` route that returns a `200 OK` response with a body of "pong".
  - **Step Dependencies**: Step 1
  - **User Instructions**: After running `docker-compose up -d --build`, navigate to `http://localhost:8080/ping` in your browser or use `curl`. You should see the "pong" response, confirming the API server is active.

- [ ] Step 4: Configure Nginx as a Reverse Proxy
  - **Task**: Add an Nginx service to the `docker-compose.yml` file to act as a reverse proxy. This will be the single public entry point for the backend, routing traffic to the appropriate service based on the URL path (`/api/*` to the Dart API, `/pb/*` to PocketBase). This standardizes access and simplifies SSL termination.
  - **Files**:
    - `backend/docker-compose.yml`: Add a new `nginx` service. It will be mapped to port 80 and 443 of the host machine and depend on the `api` and `auth` services.
    - `backend/nginx/nginx.conf`: Create the Nginx configuration file. Define `upstream` blocks for the API and PocketBase services. Create a `server` block that listens on port 80 and defines `location` blocks to proxy requests to the correct upstream based on the path.
  - **Step Dependencies**: Step 1, Step 3
  - **User Instructions**: Run `docker-compose up -d --build`. Access `http://localhost/ping`. The request should be routed through Nginx to the Dart API, and you should see the "pong" response.

## 2. Project Setup: Frontend Application
- [ ] Step 5: Scaffold SvelteKit Frontend Application
  - **Task**: Initialize a new SvelteKit project using the official command-line tool. Set up the basic project structure, including TypeScript, Tailwind CSS for styling, and Prettier for code formatting, as per the technology stack recommendations.
  - **Files**:
    - `frontend/package.json`: Manages project dependencies.
    - `frontend/svelte.config.js`: SvelteKit configuration file.
    - `frontend/vite.config.ts`: Vite build tool configuration.
    - `frontend/tailwind.config.js`: Configuration file for Tailwind CSS.
    - `frontend/src/app.html`: The main HTML shell for the application.
  - **Step Dependencies**: None
  - **User Instructions**: In a new directory named `frontend`, run `npm create svelte@latest .`. Follow the prompts to select a "Skeleton project" and add TypeScript, ESLint, Prettier, and Tailwind CSS. After initialization, run `npm install` and then `npm run dev` to start the development server.

- [ ] Step 6: Implement Basic UI Layout
  - **Task**: Create the main two-column layout of the application. This involves setting up a global layout component in SvelteKit and creating the primary user interface elements: the Cyrillic input text area on the left and the Traditional Mongolian output area on the right.
  - **Files**:
    - `frontend/src/routes/+layout.svelte`: A root layout component that will apply to all pages. It will contain the main grid or flexbox container for the two-column design.
    - `frontend/src/routes/+page.svelte`: The main page component. It will contain the two `<textarea>` elements, a "Convert" button, and placeholders for "Copy" and "Clear" buttons. Use Tailwind CSS for styling.
    - `frontend/src/app.css`: Global styles, including the import statements for Tailwind CSS.
  - **Step Dependencies**: Step 5
  - **User Instructions**: With the development server running, view the application in your browser. You should see the two text areas and a "Convert" button arranged in a two-column layout on desktop and a stacked single-column layout on mobile.

- [ ] Step 7: Setup PWA and Offline Capabilities
  - **Task**: Configure the SvelteKit application to be a Progressive Web App (PWA). This involves creating a web app manifest and a service worker to enable offline functionality and application caching.
  - **Files**:
    - `frontend/static/manifest.json`: Define PWA properties like the app's name, icons, start URL, and display mode.
    - `frontend/src/app.html`: Link to the `manifest.json`.
    - `frontend/src/service-worker.ts`: Create the service worker file. Implement basic caching strategies for the application shell and static assets using SvelteKit's built-in `$service-worker` module.
  - **Step Dependencies**: Step 5
  - **User Instructions**: Build the app (`npm run build`) and preview it (`npm run preview`). In your browser's developer tools (Application tab), you should see the manifest loaded and the service worker registered and activated.

- [ ] Step 8: Client-Side Database (IndexedDB) Setup
  - **Task**: Integrate a lightweight wrapper library for IndexedDB, such as `dexie.js`, to simplify database interactions. Define the database schema with two object stores: `userDictionary` and `communityDictionary`.
  - **Files**:
    - `frontend/src/lib/db.ts`: Create a module to initialize and configure Dexie. Define the database version and the schema for the object stores. This file will export a singleton `db` instance to be used throughout the application.
    - `frontend/package.json`: Add `dexie` as a dependency.
  - **Step Dependencies**: Step 5
  - **User Instructions**: After adding the dependency (`npm install dexie`), the application should still build and run correctly. Use the browser's developer tools to verify that an IndexedDB database with the correct name and object stores has been created.

## 3. Core Feature: Authentication
- [ ] Step 9: Implement User Authentication UI
  - **Task**: Create Svelte components for user registration, login, and a user profile display. Use the PocketBase JavaScript SDK to handle the client-side authentication logic. Manage the global authentication state using Svelte stores.
  - **Files**:
    - `frontend/src/lib/pocketbase.ts`: Initialize the PocketBase JS client with the server URL.
    - `frontend/src/lib/stores/authStore.ts`: Create a Svelte store to manage the current user's authentication state and JWT.
    - `frontend/src/routes/login/+page.svelte`: The login page component with a form for email and password.
    - `frontend/src/routes/register/+page.svelte`: The registration page component.
    - `frontend/src/lib/components/Navbar.svelte`: A navigation bar component that conditionally shows "Login/Register" or "Logout" based on the auth store.
  - **Step Dependencies**: Step 4, Step 5
  - **User Instructions**: Navigate to the `/login` and `/register` pages. You should be able to create a new user account and log in. After logging in, the navbar should update to show a logout option.

- [ ] Step 10: Implement API JWT Authentication Middleware
  - **Task**: In the Dart Shelf API, create a middleware that protects specific endpoints. This middleware will extract the JWT from the `Authorization` header of incoming requests, validate it, and reject any unauthorized requests with a `401` or `403` status code.
  - **Files**:
    - `backend/api/lib/auth_middleware.dart`: The middleware function. It will parse the "Bearer" token from the header.
    - `backend/api/lib/jwt_service.dart`: A service class responsible for JWT validation. It may need to call PocketBase's API or use its public key to verify the token signature.
    - `backend/api/bin/server.dart`: Apply the new authentication middleware to a new, protected test route (e.g., `/api/protected/ping`).
  - **Step Dependencies**: Step 3, Step 9
  - **User Instructions**: After logging in on the frontend, use the browser's developer tools to copy the JWT. Use a tool like Postman or `curl` to make a request to the new `/api/protected/ping` endpoint, including the JWT in the `Authorization` header. The request should succeed. Making the same request without the token should result in an error.

## 4. Core Feature: Conversion & Contribution
- [ ] Step 11: Implement Client-Side Conversion Engine
  - **Task**: Develop the core text conversion logic in JavaScript. This engine will load dictionaries from IndexedDB into in-memory `Map` objects for performance, process input text, handle abbreviation expansion, look up words, and highlight unconverted words.
  - **Files**:
    - `frontend/src/lib/conversionEngine.ts`: The main file containing the conversion logic. It will export functions to initialize (load dictionaries) and convert text.
    - `frontend/src/routes/+page.svelte`: Import and use the `conversionEngine`. Wire the "Convert" button to trigger the conversion process and display the results in the output text area. Unconverted words should be wrapped in a styled `<span>`.
  - **Step Dependencies**: Step 6, Step 8
  - **User Instructions**: Manually add a few test words to the `userDictionary` in IndexedDB using the browser's dev tools. Type Cyrillic text containing these words into the input area and click "Convert". The output should show the correct translations, with any unknown words highlighted with a red underline.

- [ ] Step 12: Implement "Add Word" Contribution Modal
  - **Task**: Create a modal that appears when a user clicks on a highlighted, unconverted word. The modal will display the word, its context, and provide an input for the user to submit its Traditional Mongolian equivalent. New contributions should be saved immediately to the local `userDictionary`.
  - **Files**:
    - `frontend/src/lib/components/ContributionModal.svelte`: A reusable modal component. It will receive the unconverted word as a prop and contain the form for submission.
    - `frontend/src/routes/+page.svelte`: Add an event handler that listens for clicks on the highlighted word spans. This handler will open the `ContributionModal` and pass the relevant word data to it. On modal close/save, it should update the local dictionary and re-run the conversion.
  - **Step Dependencies**: Step 11
  - **User Instructions**: Click on a red-underlined word. The contribution modal should pop up. Submitting a new translation should close the modal and instantly update the word in the main output text area.

- [ ] Step 13: Implement Contribution API Endpoint
  - **Task**: Create the backend endpoint (`POST /api/dictionary/word`) to receive new word contributions from users. The endpoint will validate the incoming data and insert it into the `WordConversionPairs` table in the PostgreSQL database with a 'pending' status.
  - **Files**:
    - `backend/api/lib/api_router.dart`: Add a new route handler for `POST /api/dictionary/word`.
    - `backend/api/lib/dictionary_service.dart`: Create a service to handle the business logic and database interaction for word contributions. This will include data validation and the SQL `INSERT` statement.
    - `backend/api/lib/models/word_pair.dart`: A Dart data class representing a `WordConversionPair`.
  - **Step Dependencies**: Step 2, Step 3
  - **User Instructions**: Use a tool like Postman to send a valid JSON payload to the `http://localhost/api/dictionary/word` endpoint. Verify that a new row is created in the `word_conversion_pairs` table in your PostgreSQL database with the status set to 'pending'.

- [ ] Step 14: Implement Frontend-to-Backend Contribution Sync
  - **Task**: Connect the frontend contribution modal to the backend API. When a user chooses to "Save & Submit," the new word pair will be sent to the backend. Implement logic to handle offline submissions using the Service Worker's Background Sync API.
  - **Files**:
    - `frontend/src/lib/components/ContributionModal.svelte`: Modify the save logic. If the user chooses to submit, make a `fetch` request to the backend API.
    - `frontend/src/service-worker.ts`: Add a 'sync' event listener. When a submission fails due to being offline, tag it for background sync. The sync event will later attempt to resend the data when connectivity is restored.
  - **Step Dependencies**: Step 12, Step 13
  - **User Instructions**: Submit a new word while online; verify it appears in the database. Go offline using browser dev tools and submit another word. The UI should indicate it's queued. Go back online; the service worker should automatically sync the submission, and the new word should appear in the database.

## 5. Moderation and Community Features
- [ ] Step 15: Implement Moderation Endpoints
  - **Task**: Create the secure backend API endpoints required for moderators to review and act upon pending submissions. This includes endpoints for fetching pending words and for approving or rejecting them, which will update the word's `approval_count` and `status`.
  - **Files**:
    - `backend/api/lib/api_router.dart`: Add new protected routes under `/api/moderation/`, such as `GET /pending` and `POST /word/:id/approve`.
    - `backend/api/lib/moderation_service.dart`: Implement the business logic for fetching pending submissions and handling the approval/rejection logic. Use database transactions to prevent race conditions when updating counts.
    - `backend/api/lib/auth_middleware.dart`: Ensure the moderation routes are protected by the JWT middleware and that it checks for a 'moderator' role.
  - **Step Dependencies**: Step 10, Step 13
  - **User Instructions**: Manually set a user's `is_moderator` flag to `true` in the PocketBase UI. Using that user's JWT, make API calls to the new moderation endpoints via Postman to ensure they are functional and properly secured.

- [ ] Step 16: Build Moderation Dashboard UI
  - **Task**: Develop the frontend interface for moderators. This will be a new, protected route in the SvelteKit app that displays a list of pending submissions fetched from the API and provides buttons to approve or reject each one.
  - **Files**:
    - `frontend/src/routes/moderation/+page.svelte`: The main dashboard component. It will fetch pending words on load and display them in a list or table.
    - `frontend/src/routes/moderation/+layout.svelte`: A layout for the moderation section that checks the user's role from the `authStore` and redirects if they are not a moderator.
    - `frontend/src/lib/stores/authStore.ts`: Add logic to parse the JWT or user object from PocketBase to determine if the user has a moderator role.
  - **Step Dependencies**: Step 9, Step 15
  - **User Instructions**: Log in as a moderator. You should be able to access the `/moderation` route and see a list of pending words. Non-moderators should be redirected or shown an error if they try to access this page. Approving/rejecting a word should remove it from the list.

## 6. Deployment and Automation
- [ ] Step 17: Configure Frontend CI/CD with GitHub Actions
  - **Task**: Create a GitHub Actions workflow to automate the deployment of the SvelteKit PWA to GitHub Pages. The workflow should trigger on a push to the `main` branch, install dependencies, build the static site, and push the build artifacts to the `gh-pages` branch.
  - **Files**:
    - `frontend/.github/workflows/deploy.yml`: The GitHub Actions workflow file. It will define the job with steps for checking out the code, setting up Node.js, building the project, and using a community action (like `peaceiris/actions-gh-pages`) to deploy.
  - **Step Dependencies**: Step 5
  - **User Instructions**: Push a commit to the `main` branch of the `frontend` repository. Go to the "Actions" tab in GitHub to monitor the workflow. Once it completes successfully, configure the repository's GitHub Pages settings to serve from the `gh-pages` branch.

- [ ] Step 18: Configure Backend CI/CD with GitHub Actions
  - **Task**: Create a GitHub Actions workflow to automate building and publishing the backend Docker images. The workflow will trigger on a push to the `main` branch, log in to Docker Hub, and then build and push the `api` and `nginx` images with an appropriate tag (e.g., the commit SHA or a version number).
  - **Files**:
    - `backend/.github/workflows/build-push.yml`: The workflow file for the backend. It will have steps to log in to a container registry (like Docker Hub), build each Docker image using `docker build`, and push them using `docker push`.
  - **Step Dependencies**: Step 1, Step 4
  - **User Instructions**: Add `DOCKER_USERNAME` and `DOCKER_PASSWORD` as secrets to your GitHub repository. Push a commit to the `main` branch of the `backend` repository. Verify in the "Actions" tab that the workflow runs and successfully pushes the images to your Docker Hub account.