## Features (MVP)
### Client-Side Conversion Engine
This is the core feature that executes the Cyrillic-to-Traditional Mongolian conversion directly in the user's browser. It prioritizes user privacy and provides an instantaneous, offline-first experience by using dictionaries stored locally and avoiding any server-side text processing.

#### Tech Involved
*   JavaScript (ESM)
*   IndexedDB API
*   Web Workers (Potential for large text to prevent UI blocking)
*   Service Worker (For PWA functionality)

#### Main Requirements
*   **Privacy-by-design**: Conversion logic must run entirely on the client, with no text ever being uploaded to a server.
*   **Offline-first**: The application must be fully functional without an internet connection once the dictionary is cached.
*   **Performance**: Conversions for substantial texts (e.g., 1000+ words) should feel instantaneous (<500ms).
*   **Accuracy**: The engine must correctly prioritize the user's local dictionary over the shared community dictionary during lookups.

### Dual-Layer Dictionary System
This system manages two distinct data sources for conversions: a private, user-specific dictionary and a larger, read-only community dictionary. User contributions are immediately saved to their local dictionary for personal use, while the community dictionary is periodically updated from the server, ensuring all users benefit from moderated, crowdsourced data.

#### Tech Involved
*   IndexedDB
*   Service Worker with Background Sync API
*   Fetch API

#### Main Requirements
*   **Immediate Local Benefit**: A user's new word/abbreviation contributions must be available to them for conversion instantly, even before moderation.
*   **Data Segregation**: The user's local dictionary and the shared community dictionary must be stored and queried separately.
*   **Efficient Syncing**: The PWA must handle an initial large dictionary download (~3MB) and subsequent smaller, incremental updates efficiently in the background without disrupting the user experience.
*   **Resilience**: The system must function correctly if a user remains offline for extended periods and then reconnects.

### Crowdsourcing & Moderation API
This is the backend service responsible for ingesting, managing, and serving all community-driven translation data. It handles user authentication for moderators, processes new word submissions, and enforces the multi-stage moderation workflow to ensure the quality of the shared dictionary.

#### Tech Involved
*   Dart Shelf (API Framework)
*   PostgreSQL (Primary Datastore)
*   PocketBase (Authentication & User Management)
*   Docker (Containerization)

#### Main Requirements
*   **Quality Control**: A rigorous, multi-tier approval system (net +5 for accepted, net -3 for rejected) is required to maintain dictionary integrity.
*   **Role-Based Access Control**: The API must securely differentiate between anonymous users, authenticated contributors, and trusted moderators.
*   **Scalability**: The database schema and API endpoints must be designed to handle millions of word pairs and thousands of concurrent users syncing data.
*   **Moderator Anonymity**: The system must support blind reviews where moderators cannot see the votes of other moderators to prevent bias.

## System Diagram
```mermaid
graph TD
    subgraph Client (Browser/PWA)
        UI[User Interface - HTML/CSS/JS]
        Engine[Conversion Engine]
        DB[IndexedDB]
        SW[Service Worker]
        
        UI -- User Input --> Engine
        Engine -- Dictionary Lookup --> DB
        UI -- Contribution --> DB
        UI -- Contribution for Review --> SW
        DB -- User & Community Dictionaries --> Engine
        SW -- Background Sync --> API
    end

    subgraph CDN (GitHub Pages / Cloudflare)
        Static[Static Assets - App Shell, Fonts]
    end

    subgraph Backend (VPS)
        API[API Server - Dart Shelf]
        Auth[Authentication - PocketBase]
        Database[(PostgreSQL)]
        
        API -- CRUD Operations --> Database
        API -- Verify Role --> Auth
        Moderator -- Moderation Actions --> API
    end

    User[User] -- Interacts With --> UI
    Moderator[Moderator] -- Manages Data --> UI
    User -- Initial Load --> CDN
    SW -- Caches --> Static
```

## List of Technical/Architecture Consideration Questions
*   **Frontend Framework Choice**: The spec mentions Vanilla JS or a lightweight framework. Given the complexity of state management (UI state, conversion choices, auth status, local/remote data), would a minimal framework like Svelte or Vue provide significant development velocity and maintainability advantages over Vanilla JS without a major performance trade-off?

That is fine to use something besides Vanilla JS. Whatever you think is best.

*   **Backend Stack Complexity**: The proposed backend uses Dart Shelf, PocketBase, and PostgreSQL. Was a more integrated "Backend-as-a-Service" like Supabase considered? Supabase uses PostgreSQL and could potentially consolidate the API and authentication layers, possibly simplifying deployment and maintenance. What are the key drivers for choosing the Dart Shelf + PocketBase combination?

I'd like to stick with Dart Shelf, PocketBase, and PostgreSQL because I am familiar with them and Supabase is maybe too expensive for me.

*   **Anonymous Contributions**: Hashing IP addresses is a good privacy measure. What is the strategy for preventing spam or low-quality anonymous submissions? Will there be stricter rate-limiting or a CAPTCHA-like mechanism for anonymous contributors?

That would be good to add rate limiting.
