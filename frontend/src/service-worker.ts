/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

// Define a unique cache name for this version of the app
const CACHE_NAME = `static-cache-${version}`;

// Assets to eagerly cache on install (app shell)
const assetsToCache = [
    ...build, // Files generated by SvelteKit build process (e.g., JS, CSS)
    ...files,  // Files in the 'static' directory (e.g., icons, manifest)
    '/'       // Cache the root route
];

// --- Install Event ---
// Fired when the service worker is installed. Caches all essential app assets.
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open(CACHE_NAME).then((cache) => {
            console.log(`[Service Worker] Caching app shell (v${version})...`);
            return cache.addAll(assetsToCache).catch((error) => {
                console.error('[Service Worker] Failed to cache some assets:', error);
            });
        })
    );
});

// --- Activate Event ---
// Fired when the service worker is activated. Cleans up old caches.
self.addEventListener('activate', (event) => {
    event.waitUntil(
        caches.keys().then(async (keys) => {
            // Delete old caches that don't match the current CACHE_NAME
            for (const key of keys) {
                if (key !== CACHE_NAME) {
                    console.log(`[Service Worker] Deleting old cache: ${key}`);
                    await caches.delete(key);
                }
            }
            // Take control of all pages within the scope
            self.clients.claim();
            console.log(`[Service Worker] Activated (v${version}).`);
        })
    );
});

// --- Fetch Event ---
// Fired for every network request. Implements a "cache-first, then network" strategy.
self.addEventListener('fetch', (event) => {
    // Only handle GET requests
    if (event.request.method !== 'GET') return;

    event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
            // If a cached response exists, return it immediately
            if (cachedResponse) {
                return cachedResponse;
            }

            // Otherwise, fetch from the network
            return fetch(event.request).then((networkResponse) => {
                // Cache successful, non-opaque, HTTP/HTTPS responses
                // Prevents caching of e.g. cross-origin requests that might be redirects
                if (networkResponse.ok && networkResponse.type === 'basic' && networkResponse.url.startsWith('http')) {
                    const responseToCache = networkResponse.clone(); // Clone response as it can only be consumed once
                    caches.open(CACHE_NAME).then((cache) => {
                        cache.put(event.request, responseToCache);
                    });
                }
                return networkResponse;
            }).catch((error) => {
                // Network request failed, and no cache match.
                console.error('[Service Worker] Fetch failed and no cache match for:', event.request.url, error);
                // You could serve a generic offline page here if one exists
                // e.g., return caches.match('/offline.html');
                throw error; // Propagate the error
            });
        })
    );
});

// --- Background Sync Event (Placeholder) ---
// This event listener will be used in a later step (Step 14) for offline data submission.
self.addEventListener('sync', (event) => {
    if (event.tag === 'new-contribution-sync') {
        console.log('[Service Worker] Background sync triggered for new contributions!');
        // Placeholder: In Step 14, logic to send queued contributions to the backend will go here.
        // event.waitUntil(syncNewContributions());
    }
});
