# Cyrillic-Traditional Mongolian Converter Technical Specification

## 1. Executive Summary
- **Project overview and objectives**: This document outlines the technical specifications for a privacy-first, offline-capable Progressive Web App (PWA) that converts Cyrillic Mongolian text to Traditional Mongolian script. The core objectives are to provide instant, client-side conversion, empower the community through a crowdsourced dictionary with a robust moderation system, and ensure a seamless user experience on both desktop and mobile platforms.
- **Key technical decisions and rationale**:
    - **Client-Side Conversion**: All text processing occurs in the browser using JavaScript and IndexedDB. This guarantees user privacy as no sensitive text is ever sent to a server.
    - **Dual-Layer Dictionary**: A user's local IndexedDB dictionary is prioritized over the shared community dictionary. This allows users' contributions to be immediately useful to them, even before community moderation.
    - **PWA with Service Workers**: This enables a full offline-first experience and efficient background synchronization of the community dictionary.
    - **Hybrid Backend**: PocketBase is used for authentication and user management due to its simplicity and robust feature set. A custom Dart Shelf API backed by PostgreSQL is used for the complex logic of dictionary submissions and moderation, providing performance and scalability.
- **High-level architecture diagram**:
```mermaid
graph TD
    subgraph Client (Browser/PWA)
        UI[User Interface - React/Svelte/Vue]
        Engine[Conversion Engine - JS]
        LocalDB[IndexedDB]
        SW[Service Worker]

        UI -- User Input --> Engine
        Engine -- Dictionary Lookup --> LocalDB
        UI -- Contributions --> LocalDB
        UI -- Server Submissions --> SW
        LocalDB -- User & Community Dictionaries --> Engine
        SW -- Background Sync --> API
    end

    subgraph CDN (GitHub Pages / Cloudflare)
        Static[Static Assets - App Shell, Fonts]
    end

    subgraph Backend (VPS with Docker)
        API[API Server - Dart Shelf]
        Auth[Authentication - PocketBase]
        Database[(PostgreSQL)]

        API -- CRUD Operations --> Database
        API -- Verify Role --> Auth
        Moderator -- Moderation Actions --> API
    end

    User[User] -- Interacts With --> UI
    Moderator[Moderator] -- Manages Data --> UI
    User -- Initial Load --> CDN
    SW -- Caches --> Static
```
- **Technology stack recommendations**:
    - **Frontend**: Lightweight JavaScript framework (e.g., Svelte or Vue) for reactive UI, Vite for build tooling.
    - **Client-Side Storage**: IndexedDB for storing user and community dictionaries.
    - **Backend API**: Dart with the Shelf framework, running in a Docker container.
    - **Authentication**: Self-hosted PocketBase instance.
    - **Database**: PostgreSQL for the community dictionary and moderation data.
    - **Hosting**: GitHub Pages with Cloudflare for the frontend PWA, and a VPS (e.g., DigitalOcean, Hetzner) for the backend Docker containers.

## 2. System Architecture
### 2.1 Architecture Overview
- **System components and their relationships**:
    - **Frontend PWA**: The single-page application that users interact with. It contains all the UI, the client-side conversion logic, and manages the local dictionaries in IndexedDB.
    - **Service Worker**: A script that runs in the background, enabling offline functionality, caching of the application shell, and handling background synchronization of the community dictionary with the backend API.
    - **Backend API (Dart Shelf)**: A stateless API responsible for ingesting new word contributions, managing the moderation workflow, and serving dictionary updates to clients.
    - **Authentication Service (PocketBase)**: Manages user registration, login, and roles (e.g., "user," "moderator"). It issues JWTs that the Dart API validates for protected endpoints.
    - **Database (PostgreSQL)**: The source of truth for all community-contributed words, abbreviations, user data (via PocketBase), and moderation logs.
- **Data flow diagrams**:
    - **Conversion Flow (Client-Side Only)**:
      ```mermaid
      sequenceDiagram
          participant User
          participant UI
          participant ConversionEngine
          participant IndexedDB

          User->>UI: Enters Cyrillic text & Clicks "Convert"
          UI->>ConversionEngine: Initiate conversion with text
          ConversionEngine->>ConversionEngine: Detect & Expand Abbreviations (lookup in IndexedDB)
          ConversionEngine->>IndexedDB: Lookup each word (Local Dict first)
          IndexedDB-->>ConversionEngine: Return Traditional Mongolian or null
          ConversionEngine->>IndexedDB: Lookup in Community Dict if not in Local
          IndexedDB-->>ConversionEngine: Return Traditional Mongolian or null
          ConversionEngine-->>UI: Return converted text with unconverted words highlighted
          UI->>User: Display result
      ```
    - **Contribution Sync Flow**:
      ```mermaid
      sequenceDiagram
          participant User
          participant UI
          participant IndexedDB
          participant ServiceWorker
          participant API

          User->>UI: Submits new word (Save & Submit)
          UI->>IndexedDB: Save word to Local Dictionary (immediate use)
          UI->>ServiceWorker: Queue submission for server
          ServiceWorker->>API: POST /api/dictionary/word (with auth token)
          API->>API: Validate data & user role
          API->>Database: Insert new word with 'pending' status
          API-->>ServiceWorker: Return success
      ```
- **Infrastructure requirements**:
    - **CDN**: A global CDN like Cloudflare for low-latency delivery of frontend static assets.
    - **VPS**: A virtual private server with Docker support to host the Dart Shelf API, PocketBase, and PostgreSQL database. Recommended minimum: 2 vCPU, 4GB RAM.
    - **Domain Name**: A custom domain name for the application.

### 2.2 Technology Stack
- **Frontend technologies and frameworks**:
    - **Framework**: SvelteKit or Vue.js. Chosen for their performance, small bundle sizes, and excellent developer experience, which are ideal for a PWA.
    - **Styling**: Tailwind CSS for a utility-first approach to building a responsive and consistent UI.
    - **State Management**: Svelte Stores or Pinia for managing global UI state like authentication status and dictionary sync progress.
- **Backend technologies and frameworks**:
    - **API**: Dart 3+ with the Shelf framework.
    - **Authentication**: PocketBase (self-hosted).
    - **Containerization**: Docker and Docker Compose for creating reproducible environments for the API, database, and auth service.
- **Database and storage solutions**:
    - **Client-Side**: IndexedDB for storing the local user dictionary and the cached community dictionary.
    - **Server-Side**: PostgreSQL 15+ for its robustness, reliability, and powerful querying capabilities for relational data.
- **Third-party services and APIs**: None. The architecture is self-contained to ensure low cost and high control.

## 3. Feature Specifications
### 3.1 Core Conversion & Contribution
- **User stories and acceptance criteria**:
    - **As a user, I can paste Cyrillic text and convert it instantly to see the Traditional Mongolian script.**
        - AC1: The conversion must happen entirely client-side.
        - AC2: For text up to 1000 words, the conversion must complete in under 500ms.
        - AC3: Words not found in any dictionary remain in Cyrillic and are visually highlighted with a red dotted underline.
    - **As a user, I can click on an unconverted word to add its translation.**
        - AC1: Clicking an unconverted word opens a modal.
        - AC2: The modal displays the word and its surrounding context (2 words before/after).
        - AC3: The user can input a Latin transliteration which is live-previewed in Menksoft script.
    - **As a user, my new contributions are available for my own use immediately.**
        - AC1: Saving a new word (either "locally only" or "locally and submit") adds it to the user's local IndexedDB dictionary.
        - AC2: The word in the main text output is immediately updated upon saving.
- **Technical requirements and constraints**:
    - The Menksoft-to-Unicode conversion algorithm must be implemented in JavaScript and executed on the copy-to-clipboard action.
    - Abbreviation detection logic (`/\b[A-Z-]{2,}\b/g`) runs before the main word-by-word conversion.
    - Dictionary lookups must be case-insensitive for Cyrillic keys.
- **Detailed implementation approach**:
    1.  On app load, the `CommunityDictionary` and `UserDictionary` are loaded from IndexedDB into in-memory JavaScript `Map` objects for fastest lookup performance.
    2.  When the "Convert" button is clicked, the input text is first processed by an abbreviation expansion function. This function iterates through detected abbreviations, looks them up in the `UserDictionary` map then the `CommunityDictionary` map, and replaces them. If an abbreviation is not found, a modal is triggered.
    3.  The text is then split into words and punctuation. Each word is looked up, first in `UserDictionary`, then in `CommunityDictionary`.
    4.  If a word has multiple translations, a modal is triggered, and the user's choice is used for all instances in the current session.
    5.  Unconverted words are wrapped in a `<span>` with a specific class for styling and a `data-word` attribute to identify them.
    6.  Event listeners are attached to these spans to trigger the contribution modal.
- **User flow diagrams**:
  ```mermaid
  graph TD
      A[User pastes text and clicks Convert] --> B{Abbreviation Found?};
      B -- Yes --> C{In Dictionary?};
      C -- Yes --> D[Replace with expansion];
      C -- No --> E[Show Abbreviation Modal];
      E --> F{User provides expansion};
      F -- Save --> D;
      F -- Skip --> G;
      B -- No --> G[Split text into words];
      G --> H{Word in User Dictionary?};
      H -- Yes --> I[Use local translation];
      H -- No --> J{Word in Community Dictionary?};
      J -- Yes --> K{Multiple Translations?};
      K -- Yes --> L[Show Choice Modal];
      L --> M[Use selected translation];
      K -- No --> N[Use community translation];
      J -- No --> O[Highlight as unconverted];
      I & M & N & O --> P[Render final output];
  ```
- **API endpoints (if applicable)**:
    - `POST /api/dictionary/word`
    - `POST /api/dictionary/abbreviation`
- **Data models involved**:
    - `WordConversionPairs`
    - `AbbreviationExpansions`
- **Error handling and edge cases**:
    - **Offline Submission**: If a user tries to "Save & Submit" while offline, the submission is saved to the local dictionary, and the UI displays a message: "You're offline. Word saved locally. It will be submitted when you're back online." The submission can be queued using the Service Worker's Background Sync API.
    - **Large Text**: For text exceeding 5000 words, the conversion logic can be offloaded to a Web Worker to prevent blocking the main UI thread. A subtle loading indicator will be shown.
- **Performance considerations**: Using `Map` objects for in-memory dictionary lookups provides O(1) average time complexity, which is critical for near-instant conversion.

### 3.2 User Authentication & Moderation
- **User stories and acceptance criteria**:
    - **As a logged-in user, I can apply to become a moderator by passing a test.**
        - AC1: The application form includes a 10-question test.
        - AC2: The user must score at least 9/10 to be able to submit the application.
        - AC3: The application is submitted to a queue for review by existing moderators.
    - **As a moderator, I can review pending submissions and approve or reject them.**
        - AC1: The moderation dashboard lists pending submissions with their context.
        - AC2: The review is blind; the contributor and other moderators' votes are not visible.
        - AC3: An approval adds +1 to a word's score, a rejection adds -1.
    - **As a moderator, I can review moderator applications and approve or reject them.**
        - AC1: The application review interface shows the applicant's test score, answers, and self-description.
        - AC2: Approving an applicant assigns them the 'moderator' role in PocketBase.
- **Technical requirements and constraints**:
    - All moderation endpoints must be protected and require a valid JWT from a user with the 'moderator' role.
    - The moderation test questions should be fetched from a secure endpoint and not be hardcoded in the frontend to prevent cheating.
- **Detailed implementation approach**:
    - Authentication is handled by the PocketBase Web SDK. On login, a JWT is stored securely (e.g., in a httpOnly cookie if server-side rendering is used, or in memory for a pure SPA).
    - The JWT is sent in the `Authorization` header for all requests to the Dart Shelf API.
    - The Dart API uses a middleware to intercept requests to protected routes. It validates the JWT against PocketBase's public key or via an API call to PocketBase to verify the token and check the user's roles.
    - The moderation system logic (approval counts, status changes) is handled entirely on the backend to maintain integrity.
        - `approval_count` reaches `1`: `status` becomes `'probation'`.
        - `approval_count` reaches `5`: `status` becomes `'accepted'`.
        - `approval_count` reaches `-3`: `status` becomes `'rejected'`.
- **API endpoints (if applicable)**:
    - `GET /api/moderator/test-questions`
    - `POST /api/moderator/apply`
    - `GET /api/moderation/pending`
    - `POST /api/moderation/word/:id/approve`
    - `POST /api/moderation/word/:id/reject`
- **Data models involved**:
    - `Users` (PocketBase)
    - `ModeratorApplications`
    - `ModeratorActions`
    - `WordConversionPairs`
- **Error handling and edge cases**:
    - **Race Conditions**: If two moderators act on the same word simultaneously, the database transaction will handle the updates sequentially. The backend will use `SELECT FOR UPDATE` if necessary to lock the row during the update transaction to prevent race conditions on the `approval_count`.
    - **Unauthorized Access**: The API will return a `403 Forbidden` status code if a non-moderator attempts to access moderation endpoints.

## 4. Data Architecture
### 4.1 Data Models
- **WordConversionPairs**: Stores the core translation data.
    - `word_id` (BIGSERIAL, PRIMARY KEY)
    - `cyrillic_word` (TEXT, NOT NULL, INDEX)
    - `traditional_mongolian_menksoft` (TEXT, NOT NULL)
    - `traditional_mongolian_latin` (TEXT, NOT NULL)
    - `context_before` (TEXT)
    - `context_after` (TEXT)
    - `status` (VARCHAR(10), NOT NULL, DEFAULT 'pending', INDEX) - Values: 'pending', 'probation', 'accepted', 'rejected'
    - `approval_count` (INTEGER, NOT NULL, DEFAULT 0, INDEX)
    - `contributor_id` (VARCHAR(30), NULL) - Foreign key to PocketBase users table ID
    - `contributor_ip_hash` (VARCHAR(64), NULL)
    - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
    - `updated_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
- **AbbreviationExpansions**: Stores abbreviation definitions.
    - `abbreviation_id` (BIGSERIAL, PRIMARY KEY)
    - `abbreviation` (TEXT, NOT NULL, INDEX)
    - `expansion` (TEXT, NOT NULL)
    - `status`, `approval_count`, etc. (same as `WordConversionPairs`)
- **ModeratorActions**: Logs every moderation action for auditing.
    - `action_id` (BIGSERIAL, PRIMARY KEY)
    - `word_id` (BIGINT, NULL, FOREIGN KEY REFERENCES WordConversionPairs(word_id))
    - `abbreviation_id` (BIGINT, NULL, FOREIGN KEY REFERENCES AbbreviationExpansions(abbreviation_id))
    - `moderator_id` (VARCHAR(30), NOT NULL) - Foreign key to PocketBase users table ID
    - `action_type` (VARCHAR(10), NOT NULL) - Values: 'approve', 'reject', 'edit'
    - `timestamp` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())
- **Users**: Managed by PocketBase. Custom fields:
    - `is_moderator` (BOOLEAN, DEFAULT false)
- **ModeratorApplications**: Tracks applications to become a moderator.
    - `application_id` (SERIAL, PRIMARY KEY)
    - `user_id` (VARCHAR(30), NOT NULL)
    - `test_score` (INTEGER, NOT NULL)
    - `test_answers` (JSONB)
    - `self_description` (TEXT)
    - `status` (VARCHAR(10), NOT NULL, DEFAULT 'pending') - Values: 'pending', 'approved', 'rejected'
    - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT NOW())

### 4.2 Data Storage
- **Database selection and rationale**:
    - **PostgreSQL**: Chosen for its robustness, support for advanced indexing (e.g., GIN indexes for text search), and JSONB data type, making it ideal for the structured and auditable data required by the moderation system.
    - **IndexedDB**: The standard browser API for persistent client-side storage, necessary for the PWA's offline capabilities and for storing the large dictionary files without blocking the main thread.
- **Data persistence strategies**:
    - **Client**: Two IndexedDB object stores: `userDictionary` (keyed by `cyrillic_word`) and `communityDictionary` (keyed by `cyrillic_word`).
    - **Server**: All data is persisted in PostgreSQL.
- **Caching mechanisms**:
    - **Client**: The entire community dictionary (probation and accepted words) is downloaded, gzipped, and stored in IndexedDB. The Service Worker caches the app shell and static assets for instant loading.
    - **Server**: The gzipped full dictionary file can be pre-generated and cached on the server's filesystem or in a Redis cache to avoid generating it on every request.
- **Backup and recovery procedures**:
    - The PostgreSQL database will be backed up daily using `pg_dump`. Backups will be stored in a secure, off-site location (e.g., S3-compatible object storage).
    - Point-in-time recovery (PITR) will be configured to allow for restoration to any point within the last 7 days.

## 5. API Specifications
### 5.1 Internal APIs
- **Endpoint**: `POST /api/dictionary/word`
    - **Description**: Submit a new word or abbreviation contribution.
    - **Auth**: Optional (can be anonymous).
    - **Request Body Schema**:
      ```json
      {
        "cyrillic_word": "Монгол",
        "traditional_mongolian_latin": "monggol",
        "context_before": "Би бол",
        "context_after": "хүн."
      }
      ```
    - **Response Schema (201 Created)**:
      ```json
      {
        "status": "success",
        "message": "Contribution received and is pending review."
      }
      ```
    - **Rate Limiting**: 10 submissions per hour per IP address for anonymous users; 60 per hour for authenticated users.

- **Endpoint**: `GET /api/dictionary/full`
    - **Description**: Download the complete, gzipped community dictionary.
    - **Auth**: None.
    - **Request Parameters**: `?version=<string>` (optional, for cache busting).
    - **Response**: A `application/gzip` file containing a JSON array of word pairs.
      ```json
      [{ "c": "Монгол", "t": "monggol_menksoft_encoding" }, ...]
      ```
    - **Rate Limiting**: 5 requests per hour per IP.

- **Endpoint**: `POST /api/moderation/word/{id}/approve`
    - **Description**: A moderator approves a word.
    - **Auth**: Required (moderator role).
    - **Request Body Schema**: None.
    - **Response Schema (200 OK)**:
      ```json
      {
        "word_id": 12345,
        "new_approval_count": 1,
        "new_status": "probation"
      }
      ```
    - **Rate Limiting**: 200 actions per hour per moderator.

### 5.2 External Integrations
- This project has no external service integrations beyond the self-hosted PocketBase instance for authentication. Communication between the Dart API and PocketBase will be via PocketBase's REST API for user/role verification if needed.

## 6. Security & Privacy
### 6.1 Authentication & Authorization
- **Authentication mechanism and flow**:
    1. User signs up/logs in via the PocketBase SDK on the frontend.
    2. PocketBase returns a JWT.
    3. The frontend stores this JWT and includes it as a Bearer token in the `Authorization` header for all requests to the Dart API.
- **Authorization strategies and role definitions**:
    - **Anonymous**: Can convert text, download the dictionary, and submit contributions (with stricter rate limits).
    - **Authenticated User**: Can do everything an anonymous user can, plus apply for moderation, and view their contribution history.
    - **Moderator**: Can do everything an authenticated user can, plus access the moderation dashboard to approve/reject words and moderator applications. This is controlled by the `is_moderator` boolean flag in the PocketBase `users` collection. The Dart API verifies this role on every protected endpoint.
- **Session management**: Handled by the PocketBase SDK, which manages token storage and refresh.

### 6.2 Data Security
- **Encryption strategies**:
    - **In Transit**: All communication between the client, CDN, and backend servers will be encrypted using TLS 1.2 or higher (HTTPS).
    - **At Rest**: User passwords are automatically hashed by PocketBase. The PostgreSQL database will be configured on an encrypted filesystem.
- **PII handling and protection**:
    - The only PII collected for anonymous users is the IP address, which will be hashed using SHA-256 before being stored in the `contributor_ip_hash` field. Raw IP addresses will not be stored.
- **Compliance requirements**: While not strictly bound by GDPR/CCPA for this project, best practices will be followed. A privacy policy will clearly state what data is collected and why.

### 6.3 Application Security
- **Input validation and sanitization**: All user-submitted text (contributions, moderator applications) will be sanitized on the backend before being inserted into the database to prevent XSS attacks. The frontend will also escape any rendered user-generated content.
- **OWASP compliance measures**:
    - **Injection**: All database queries will use parameterized statements to prevent SQL injection.
    - **Broken Authentication**: JWTs will have a short expiration time and be handled by the robust PocketBase library.
    - **Security Misconfiguration**: Strict CORS policies will be enforced on the backend API. Security headers like `Content-Security-Policy` and `X-Content-Type-Options` will be implemented.

## 7. User Interface Specifications
This section is based on the "Functional UX/UI Style Guide" provided in the project request.

### 7.1 Design System
- **Visual design principles**: The design is governed by the principle of **Instant Clarity**. The UI is minimal and content-first, using generous whitespace to reduce cognitive load and guide the user.
- **Component library structure**: A flat component structure will be used, organized by function (e.g., `/components/layout`, `/components/forms`, `/components/conversion`).
- **Responsive design approach**: A mobile-first approach will be used. The layout will be a single stacked column on mobile and transition to a two-column layout on larger screens (tablets and desktops) using Tailwind CSS breakpoints.
- **Accessibility standards**: WCAG 2.1 AA compliance is the minimum target.

### 7.2 Design Foundations
#### 7.2.1 Color System
- **Primary**: White (`#FFFFFF`), Off-White (`#F9F9F9`)
- **Text**: Near-Black (`#1A1A1A`), Medium Gray (`#6B6B6B`)
- **Accent/Action**: Royal Blue (`#0052FF`)
- **Semantic**: Green (`#28A745` for success), Red (`#DC3545` for unconverted words/errors)

#### 7.2.2 Typography
- **UI Font**: Inter (sans-serif)
- **Output Font**: Menksoft
- **Type Scale**: Display Title (`24px`), Text Area (`18px`), Button (`16px`), Body (`14px`). Mobile sizes are slightly reduced.

#### 7.2.3 Spacing & Layout
- **Base unit system**: 8pt grid system. All spacing and sizing will be in multiples of 8px (e.g., `8px`, `16px`, `24px`, `32px`).
- **Breakpoints**: Mobile (<768px), Tablet (768px - 1024px), Desktop (>1024px).

#### 7.2.4 Interactive Elements
- **Button styles**:
    - **Primary**: Solid Royal Blue fill, white text. Darkens on hover.
    - **Secondary**: Transparent background, light gray border, blue text. Fills with a light blue tint on hover.
- **States**: All interactive elements will have distinct `default`, `hover`, `active/pressed`, and `disabled` states. Focus states will use a visible blue ring for accessibility.

### 7.3 User Experience Flows
- **Key user journeys with wireframes/mockups**:
    - **Main Conversion Flow**:
        - Empty State: Two panels, input on left, output on right. Clear call-to-action "Convert" button.
        - Converted State: Traditional Mongolian text appears vertically in the output panel. Unconverted words have a red dotted underline. "Copy" and "Clear" buttons are active.
    - **Contribution Flow**:
        ```mermaid
        graph TD
            A[User clicks red-underlined word] --> B(Contribution Modal Appears);
            B -- Shows --> C[Context Snippet];
            B -- Contains --> D[Latin Input Field & Live Preview];
            B -- Contains --> E[Save Options: Local / Local+Submit];
            D -- User types --> D;
            E -- User selects & clicks Save --> F{Is Online?};
            F -- Yes --> G[Save locally & submit to API];
            F -- No --> H[Save locally & queue submission];
            G & H --> I(Modal Closes);
            I --> J[Word in main UI updates instantly];
        ```

## 8. Infrastructure & Deployment
### 8.1 Infrastructure Requirements
- **Hosting environment**:
    - **Frontend**: Static hosting provider (GitHub Pages).
    - **Backend**: VPS running Docker.
- **Server requirements**:
    - Docker and Docker Compose installed.
    - Nginx or Caddy as a reverse proxy to handle SSL termination and route traffic to the appropriate containers (Dart API, PocketBase).
- **Network architecture**: The reverse proxy will be the only public-facing service. It will route `/api/*` requests to the Dart container and `/pb/*` requests to the PocketBase container. The PostgreSQL database will only be accessible from within the Docker network.

### 8.2 Deployment Strategy
- **CI/CD pipeline configuration**:
    - **Frontend**: A GitHub Action will be triggered on pushes to the `main` branch. It will build the Svelte/Vue application, run tests, and deploy the static assets to the `gh-pages` branch.
    - **Backend**: A separate GitHub Action will be triggered for the backend repository. It will build the Dart application into a Docker image, run tests, and push the image to Docker Hub.
- **Environment management**:
    - **Development**: Developers run all services locally using Docker Compose.
    - **Staging**: (Optional but recommended) A separate VPS to test new features before production.
    - **Production**: The main public-facing VPS.
- **Deployment procedures and rollback strategies**:
    - To deploy a new backend version, a script on the production VPS will run `docker-compose pull` to fetch the new image from Docker Hub and then `docker-compose up -d` to restart the services with the new image.
    - **Rollback**: If a deployment fails, the previous Docker image tag can be manually specified in the `docker-compose.yml` file and the services can be redeployed. Database migrations will have corresponding rollback scripts.